/********************************************************************************
#
*  * Copyright (c) 2019 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Alvaro Miyazawa - initial definition
 ********************************************************************************/

/*
 * generated by Xtext 2.17.1
 */
package circus.robocalc.robochart.textual.validation

import circus.robocalc.robochart.ANNController
import circus.robocalc.robochart.ANNOperation
import circus.robocalc.robochart.ANNParameters
import circus.robocalc.robochart.ActivationFunction
import circus.robocalc.robochart.And
import circus.robocalc.robochart.ArrayExp
import circus.robocalc.robochart.AsExp
import circus.robocalc.robochart.Assignment
import circus.robocalc.robochart.BooleanExp
import circus.robocalc.robochart.Call
import circus.robocalc.robochart.CallExp
import circus.robocalc.robochart.Cat
import circus.robocalc.robochart.Clock
import circus.robocalc.robochart.ClockExp
import circus.robocalc.robochart.ClockReset
import circus.robocalc.robochart.Communication
import circus.robocalc.robochart.CommunicationStmt
import circus.robocalc.robochart.CommunicationType
import circus.robocalc.robochart.Connection
import circus.robocalc.robochart.ConnectionNode
import circus.robocalc.robochart.Context
import circus.robocalc.robochart.Controller
import circus.robocalc.robochart.ControllerDef
import circus.robocalc.robochart.ControllerRef
import circus.robocalc.robochart.Different
import circus.robocalc.robochart.Div
import circus.robocalc.robochart.DuringAction
import circus.robocalc.robochart.EntryAction
import circus.robocalc.robochart.Enumeration
import circus.robocalc.robochart.Equals
import circus.robocalc.robochart.Event
import circus.robocalc.robochart.ExitAction
import circus.robocalc.robochart.Expression
import circus.robocalc.robochart.FieldDefinition
import circus.robocalc.robochart.Final
import circus.robocalc.robochart.FloatExp
import circus.robocalc.robochart.FunctionType
import circus.robocalc.robochart.GeneralController
import circus.robocalc.robochart.GeneralOperation
import circus.robocalc.robochart.GreaterOrEqual
import circus.robocalc.robochart.GreaterThan
import circus.robocalc.robochart.IfStmt
import circus.robocalc.robochart.Iff
import circus.robocalc.robochart.Implies
import circus.robocalc.robochart.Initial
import circus.robocalc.robochart.IntegerExp
import circus.robocalc.robochart.Interface
import circus.robocalc.robochart.Junction
import circus.robocalc.robochart.LambdaExp
import circus.robocalc.robochart.LessOrEqual
import circus.robocalc.robochart.LessThan
import circus.robocalc.robochart.Literal
import circus.robocalc.robochart.MatrixType
import circus.robocalc.robochart.Minus
import circus.robocalc.robochart.Modulus
import circus.robocalc.robochart.Mult
import circus.robocalc.robochart.NamedElement
import circus.robocalc.robochart.Neg
import circus.robocalc.robochart.NodeContainer
import circus.robocalc.robochart.Not
import circus.robocalc.robochart.Operation
import circus.robocalc.robochart.OperationDef
import circus.robocalc.robochart.OperationRef
import circus.robocalc.robochart.OperationSig
import circus.robocalc.robochart.Or
import circus.robocalc.robochart.ParExp
import circus.robocalc.robochart.Parameter
import circus.robocalc.robochart.Plus
import circus.robocalc.robochart.PrimitiveType
import circus.robocalc.robochart.ProbabilisticJunction
import circus.robocalc.robochart.ProductType
import circus.robocalc.robochart.QuantifierExpression
import circus.robocalc.robochart.RCModule
import circus.robocalc.robochart.RecordExp
import circus.robocalc.robochart.RecordType
import circus.robocalc.robochart.RefExp
import circus.robocalc.robochart.RoboChartFactory
import circus.robocalc.robochart.RoboChartPackage
import circus.robocalc.robochart.RoboticPlatform
import circus.robocalc.robochart.RoboticPlatformDef
import circus.robocalc.robochart.RoboticPlatformRef
import circus.robocalc.robochart.SeqExp
import circus.robocalc.robochart.SeqStatement
import circus.robocalc.robochart.SetComp
import circus.robocalc.robochart.SetExp
import circus.robocalc.robochart.StateClockExp
import circus.robocalc.robochart.StateMachine
import circus.robocalc.robochart.StateMachineBody
import circus.robocalc.robochart.StateMachineDef
import circus.robocalc.robochart.StateMachineRef
import circus.robocalc.robochart.Statement
import circus.robocalc.robochart.Transition
import circus.robocalc.robochart.TupleExp
import circus.robocalc.robochart.Type
import circus.robocalc.robochart.TypeRef
import circus.robocalc.robochart.VarRef
import circus.robocalc.robochart.Variable
import circus.robocalc.robochart.VariableModifier
import circus.robocalc.robochart.VectorType
import circus.robocalc.robochart.Wait
import circus.robocalc.robochart.textual.RoboCalcTypeProvider
import com.google.inject.Inject
import java.util.ArrayList
import java.util.Collection
import java.util.HashMap
import java.util.HashSet
import java.util.LinkedList
import java.util.List
import java.util.Map
import java.util.Set
import java.util.function.BiConsumer
import java.util.function.Consumer
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.serializer.ISerializer
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import java.util.function.Function
import circus.robocalc.robochart.ANNParameters

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RoboChartValidator extends AbstractRoboChartValidator {
	
	@Inject protected extension RoboCalcTypeProvider
	@Inject protected IQualifiedNameProvider qnp
	@Inject protected IResourceDescriptions rds;
	
	@Inject ISerializer s;

	@Inject protected extension PrintingServices
	
	def print(EObject o) {
		return s.serialize(o)
	}

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					RoboChartPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	public static val NO_INITIAL = 'noInitialJunction'
	public static val COMPOSITE_STATE_WITHOUT_STATE = 'compositeStateWithoutState'
	public static val ASSIGNEMENT_TO_PARAMETER = 'assignmentToParameter'

	/* S2 */
	@Check
	def stateWFC(circus.robocalc.robochart.State s) {
		if (s.actions.filter[a|a instanceof EntryAction].size > 1) {
			error(
				'State ' + s.name + ' should have at most one entry action',
				RoboChartPackage.Literals.STATE__ACTIONS,
				'stateWithMultipleEntryActions'
			)
		}
		if (s.actions.filter[a|a instanceof DuringAction].size > 1) {
			error(
				'State ' + s.name + ' should have at most one during action',
				RoboChartPackage.Literals.STATE__ACTIONS,
				'stateWithMultipleDuringActions'
			)
		}
		if (s.actions.filter[a|a instanceof ExitAction].size > 1) {
			error(
				'State ' + s.name + ' should have at most one entry action',
				RoboChartPackage.Literals.STATE__ACTIONS,
				'stateWithMultipleExitActions'
			)
		}

	}

	@Check
	def initialWFC(Initial i) {
		val parent = i.eContainer as NodeContainer
		/* IJ1 */
		if (parent.transitions.filter[t|t.target === i].size > 0) {
			error(
				'A transition cannot target the initial junction in ' + parent.name,
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noTransitionToInitial'
			)
		}
		/* IJ2 */
		if (parent.transitions.filter[t|t.source === i].size === 0) {
			error(
				'An initial junction in ' + parent.name + ' should have at least one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionFromJunction'
			)
		}
		if (parent.transitions.filter[t|t.source === i].size > 1) {
			error(
				'An initial junction in ' + parent.name + ' should not have more than one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionFromJunction'
			)
		}
	}

	@Check
	def finalWFC(Final f) {
		val parent = f.eContainer as NodeContainer
		/* FS1 */
		if (parent.transitions.filter[t|t.source === f].size > 0) {
			error(
				'A transition cannot start in the final state in ' + parent.name,
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noTransitionFromFinal'
			)
		}
		/* FS2 */
		if (f.actions.size > 0) {
			error(
				'A final state cannot have actions',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noActionsInFinalState'
			)
		}
		/* FS3 (nodes) */
		if (f.nodes.size > 0) {
			error(
				'A final state cannot have sub-nodes',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noSubNodesInFinalState'
			)
		}
		/* FS3 (transitions) */
		if (f.transitions.size > 0) {
			error(
				'A final state cannot have transitions',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noTransitionsInFinalState'
			)
		}
		
//		TODO: Check is this is needed or not. It is no longer a WFC in the reference manual.
//		if (parent.transitions.filter[t|t.target === f].size === 0) {
//			error(
//				'The final state in ' + parent.name + ' should have at least one incoming transition',
//				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//				'transitionToJunction'
//			)
//		}
	}

	@Check
	def transitionWFC(Transition t) {
		/* J3 */
		if (t.trigger !== null && t.trigger.event !== null) {
			if (!(t.source instanceof circus.robocalc.robochart.State)) {
				error(
					'A transition containing a trigger must start on a state',
					RoboChartPackage.Literals.TRANSITION__TRIGGER,
					'transitionWithTriggerFromNonState'
				)
			}
		}
		/* T1 */
		val srcParent = t.source.eContainer
		val tgtParent = t.target.eContainer
		if (srcParent !== tgtParent) {
			error(
				'The source and target of a transition should belong to the same container',
				RoboChartPackage.Literals.TRANSITION__SOURCE,
				'noInterlevelTransition'
			)
		}
		
		if (t.source instanceof ProbabilisticJunction) {
			/* PJ1 */
			if (t.probability === null) {
				error(
					'A transition from a probabilistic junction must have a probability value',
					RoboChartPackage.Literals.TRANSITION__PROBABILITY,
					'transitionWithoutProbabilityFromProbabilisticJunction'
				)
			}
			/* PJ2 */
			if (t.condition !== null) {
				error(
					'A transition from a probabilistic junction must not have a guard condition',
					RoboChartPackage.Literals.TRANSITION__CONDITION,
					'transitionWithConditionFromProbabilisticJunction'
				)
			}
		}
		
		if (t.probability !== null) {
			/* PT1 */
			if (!(t.source instanceof ProbabilisticJunction)) {
				error(
					'A transition with a probability value must start from a probabilistic junction',
					RoboChartPackage.Literals.TRANSITION__PROBABILITY,
					'transitionWithProbabilityFromNonProbabilisticJunction'
				)
			}
			/* PT2 */
			val r = probExprBetween0_1(t.probability);
			if (r === 2) {
				warning(
					'The probability value might not be between 0 to 1',
					RoboChartPackage.Literals.TRANSITION__PROBABILITY,
					'probabilityNotWithin0_1'
				)
			} else if (r === 1) {
				error(
					'The probability value must be between 0 to 1',
					RoboChartPackage.Literals.TRANSITION__PROBABILITY,
					'probabilityNotWithin0_1'
				)
			}
		}
	}

	
	/* J1 */
	@Check
	def junctionWFC1(Junction j) {
		if(j instanceof Initial) return
		val parent = j.eContainer as NodeContainer
		if (parent.transitions.filter[t|t.source === j].size === 0) {
			error(
				'A junction in ' + parent.name + ' should have at least one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionFromJunction'
			)
		}
	}

	@Check
	def junctionWFC2(Junction j) {
		if(j instanceof Initial) return
		val parent = j.eContainer as NodeContainer
		if (parent.transitions.filter[t|t.target === j].size === 0) {
			error(
				'A junction in ' + parent.name + ' should have at least one incoming transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionToJunction'
			)
		}
	}

	@Check
	def checkAssignmentToParameter(VarRef a) {
		if (a.name instanceof Parameter)
			error(
				'It is not possible to assign to a parameter',
				RoboChartPackage.Literals.VAR_REF__NAME,
				ASSIGNEMENT_TO_PARAMETER
			)
	}

	/* STM3 and (because OperationDef is a NodeContainer) O1:STM3 */
	@Check
	def checkStateMachineHasInitialState(NodeContainer stm) {
		if (stm.nodes.size > 0 && stm.nodes.filter(Initial).size !== 1)
			warning(
				'A composite state should have exactly one initial state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				NO_INITIAL
			)
	}
	
	@Check
	def checkStateMachineHasInitialState(StateMachineDef stm) {
		if (stm.nodes.filter(Initial).size !== 1)
			error(
				'A state machine should have exactly one initial state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				NO_INITIAL
			)
	}

	/* STM3 */
	/* TODO: redundant with @method checkStateMachineHasInitialState? */
	@Check
	def checkStateInitialState(circus.robocalc.robochart.State s) {
		if (s.nodes.size > 0 && s.nodes.filter(Initial).size !== 1)
			warning(
				'A state machine or composite state should have exactly one initial state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				NO_INITIAL
			)
	}

	/* STM4 and (because OperationDef is a NodeContainer) O1:STM4 */
	@Check
	def checkNodeContainerHasStates(NodeContainer c) {
		if (c.nodes.size > 0 && c.nodes.filter [ n |
			n instanceof circus.robocalc.robochart.State || n instanceof Final
		].size === 0)
			error(
				'A composite state should have at least one state or final state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				COMPOSITE_STATE_WITHOUT_STATE
			)
	}

	/* STM6 */
	@Check
	def wfcSTM6_noOpDeclInStms(StateMachineDef stm) {
		if(!stm.getOperations().isEmpty()) {
			error(
				"STM6: State machines must not have operations declared directly within them",
				RoboChartPackage.Literals.BASIC_CONTEXT__OPERATIONS
			)			
		}
	}

	/* TODO: generalisation of stmDef, to be substituted */
	def Context getContext(ConnectionNode cn) {
		if (cn instanceof StateMachineDef)
			return cn as StateMachineDef
		else if (cn instanceof ControllerDef)
			return cn as ControllerDef
		else if (cn instanceof RoboticPlatformDef)
			return cn as RoboticPlatformDef
		else if (cn instanceof StateMachineRef)
			return cn.ref
		else if (cn instanceof ControllerRef)
			return cn.ref
		else if (cn instanceof RoboticPlatformRef)
			return cn.ref
	}
	
	def stmDef(StateMachine s) {
		if (s instanceof StateMachineRef)
			return s.ref
		else
			s as StateMachineDef
	}
	
	/**
	 * Resolves an operation to its definition.
	 * 
	 * @param it the operation, which may be a reference
	 * @return the operation definition (as a general operation; may be ANN)
	 */
	def GeneralOperation opDef(Operation it) {
		switch it {
			OperationRef : ref
			GeneralOperation : it
		}
	}

//	@Check
//	def checkRequiredVariables(ControllerDef c) {
//		val rvars = new HashSet<String>() 
//		for (s: c.machines) {
//			for (i: s.stmDef.RInterfaces) {
//				for (vl: i.variableList) {
//					rvars.addAll(vl.vars.map[v|v.name])
//				}				
//			}
//		}
//		val prvars = new HashSet<String>()
//		for (i: c.RInterfaces) {
//			for (vl: i.variableList) {
//				prvars.addAll(vl.vars.map[v|v.name])
//			}				
//		}
//		for (i: c.PInterfaces) {
//			for (vl: i.variableList) {
//				prvars.addAll(vl.vars.map[v|v.name])
//			}
//		}
//		for (vl: c.variableList) {
//			prvars.addAll(vl.vars.map[v|v.name])
//		}
//		if (!(prvars.containsAll(rvars))) {
//			var s = ""
//			var started = false
//			for (v: rvars) {
//				if (!prvars.contains(v)) {
//					if (started) s += ', '
//					s +=  v
//					started = true
//				}
//			}
//			error('A controller should either provide or require all variables required by its state machines. Missing variables: '+s,
//			RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//			"unsatisfiedRequiredVariables")
//		}
//	}

	/**
	 * Resolves a controller to its definition.
	 * 
	 * @param it the controller, which may be a reference
	 * @return the controller definition (as a general controller; may be ANN)
	 */
	def GeneralController ctrlDef(Controller it) {
		switch it {
			ControllerRef : ref
			GeneralController : it
		}
	}

	def rpDef(RoboticPlatform rp) {
		if (rp instanceof RoboticPlatformRef)
			return rp.ref
		else
			rp as RoboticPlatformDef
	}

	// need to update checkRequiredVariables with type comparison when type checker is working
//
//	@Check
//	def checkRequiredVariables(Module m) {
//		val rvars = new HashSet<String>() 
//		for (c: m.nodes) {
//			if (c instanceof Controller) {
//				for (i: c.ctrlDef.RInterfaces) {
//					for (vl: i.variableList) {
//						rvars.addAll(vl.vars.map[v|v.name])
//					}				
//				}	
//			}
//		}
//		val pvars = new HashSet<String>()
//		for (r: m.nodes) {
//			if (r instanceof RoboticPlatform) {
//				for (i: r.rpDef.PInterfaces) {
//					for (vl: i.variableList) {
//						pvars.addAll(vl.vars.map[v|v.name])
//					}				
//				}
//				for (vl: r.rpDef.variableList) {
//					pvars.addAll(vl.vars.map[v|v.name])
//				}
//			}
//		}
//		if (!(pvars.containsAll(rvars))) {
//			var s = ""
//			var started = false
//			for (v: rvars) {
//				if (!pvars.contains(v)) {
//					if (started) s += ', '
//					s +=  v
//					started = true
//				}
//			}
//			error('Module '+m.name+' does not provide all variables required by its controllers. Missing variables: '+s,
//			RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//			"unsatisfiedRequiredVariables")
//		}
//	}
	public static val NO_INITIAL_TRANSITION = 'noInitialTransition'

	@Check
	/* IJ2 */
	def initialStateLeadsToState(Initial i) {
		val c = i.eContainer
		val ts = c.eContents.filter(Transition).toList.filter [ t |
			t.source === i
		/* && (t.target instanceof circus.robocalc.robochart.State)*/
		].toList
		if (ts.size !== 1)
			warning(
				'An initial junction must have exactly one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				NO_INITIAL_TRANSITION
			)
	}

	def inputEvents(StateMachineBody stm) {
		val input = new HashSet<Event>()
		stm.eAllContents.filter(Transition).forEach [ t |
			if(t.trigger !== null && t.trigger.event !== null) input.add(t.trigger.event)
		]
		input
	}

	def outputEvents(StateMachineBody stm) {
		val output = new HashSet<Event>()
		stm.eAllContents.filter(CommunicationStmt).forEach[s|output.add(s.communication?.event)]
		output
	}

	def StateMachineBody getStateMachineBody(EObject o) {
		if (o instanceof StateMachineBody) {
			return o as StateMachineBody
		} else {
			return o.eContainer.stateMachineBody
		}
	}

	/*@Check
	 * def checkInputEvents(Transition t) {
	 * 	if (t.trigger !== null && t.trigger.event !== null && outputEvents(t.stateMachineBody).contains(t.trigger.event))
	 * 		error('Input event being used as output event',
	 * 			RoboChartPackage.Literals.TRANSITION__TRIGGER,
	 * 			'InputAsOutput'
	 * 		)
	 * }
	 * 
	 * @Check
	 * def checkOutputEvents(SendEvent t) {
	 * 	if (t.trigger !== null && t.trigger.event !== null && inputEvents(t.stateMachineBody).contains(t.trigger?.event))
	 * 		error('Output event being used as input event',
	 * 			RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
	 * 			'OutputAsInput'
	 * 		)
	 * }
	 */
	@Check
	def datatypeHasFields(RecordType d) {
		if (d.fields.size === 0) {
			error(
				'A datatype should have at least one field',
				RoboChartPackage.Literals.RECORD_TYPE__FIELDS,
				'DataTypeWithoutFields'
			)
		}
	}

	@Check
	def tupleHasNatIndex(ArrayExp d) {
		val type = d.value.typeFor
		if (type instanceof ProductType) {
			if (d.parameters.size !== 1) {
				error('Tuple access should contain exactly one index', RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS,
					'TupleIndexNotSingle')
			}
			if (d.parameters.size > 0 && !(d.parameters.get(0) instanceof IntegerExp)) {
				error('Tuple access index should be numeral', RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS,
					'TupleIndexNonNumeral')
			}
			if (d.parameters.size > 0 && d.parameters.get(0) instanceof IntegerExp) {
				val i = (d.parameters.get(0) as IntegerExp).value
				if (i < 1 || i > (type as ProductType).types.size) {
					error('Tuple access index out of range (' + i + ' out of ' + (type as ProductType).types.size + ")",
						RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS, 'TupleIndexOutOfBounds')
				}
			}
		} else if (type instanceof TypeRef && (type as TypeRef).ref instanceof Literal) {
			val c = (type as TypeRef).ref as Literal
			if (c.types.size > 0 && d.parameters.size > 0 && !(d.parameters.get(0) instanceof IntegerExp)) {
				error('Constant access index should be numeral', RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS,
					'ConstantIndexNonNumeral')
			}
			if (d.parameters.size > 0 && d.parameters.get(0) instanceof IntegerExp) {
				val i = (d.parameters.get(0) as IntegerExp).value
				if (i < 1 || i > c.types.size) {
					error('Constant access index out of range (' + i + ' out of ' + c.types.size + ")",
						RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS, 'ConstantIndexOutOfBounds')
				}
			}
		}
	}

	@Check
	def roboticPlatformWFC(RoboticPlatformDef rp) {
		/* RP1 */
		for (i : rp.RInterfaces) {
			error(
				rp.name + ' is a robotic platform and cannot require interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__RINTERFACES,
				'RPNoRequiredInterfaces'
			)
		}
		/* RP2 */
		for (Interface i : rp.interfaces) {
			if (i.variableList.size > 0)
				error(
					getName(rp) + ' cannot define interface ' + i.name + ' because it contains variables',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'UsedInterfaceWithOnlyEvents'
				)
				
			if (i.clocks.size > 0)
				error(
					getName(rp) + ' cannot define interface ' + i.name + ' because it contains clocks',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'UsedInterfaceWithOnlyEvents'
				)
		}
		
		/* RP3 */
		if (rp.clocks.size > 0) {
			error(
				getName(rp) + ' cannot declare clocks',
				RoboChartPackage.Literals.BASIC_CONTEXT__CLOCKS,
				'NoClocksInRoboticPlatform'
			)
		}
	}

	@Check
	/* O1:STM1 */
	def operationDefWFC(OperationDef o) {
		for (i : o.PInterfaces) {
			error(
				o.name + ' is an operation definition and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'OperationNoProvidedInterfaces'
			)
		}
	}

	@Check
	def requiredWFC(Context c) {
		/* I1 */
		for (i : c.RInterfaces) {
			if (i.events.size > 0) {
				error(
					getName(c) + ' cannot require interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'RequiredInterfaceWithEvents'
				)
			}
		}

		/* I1 */
		for (i : c.PInterfaces) {
			if (i.events.size > 0) {
				error(
					getName(c) + ' cannot provide interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ProvidedInterfaceWithEvents'
				)
			}
			
			if (i.clocks.size > 0) {
				error(
					getName(c) + ' cannot provide interface ' + i.name + ' because it contains clocks',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ProvidedInterfaceWithClocks'
				)
			}
		}

		/* I2, together with I2 implies STM2 and (because OperationDef is a Context) O1:STM2 */
		for (Interface i : c.interfaces) {
			if (i.operations.size > 0)
				error(
					getName(c) + ' cannot define interface ' + i.name + ' because it contains operations',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'UsedInterfaceWithOnlyEvents'
				)
		}
	}

	@Check
	def controllerWFC(ControllerDef c) {
		/* C8 */
		val opcount = new HashMap<GeneralOperation,Integer>()
		for (o: c.LOperations) {
			val def = opDef(o)
			if (def !== null) {
				val cnt = opcount.getOrDefault(def, 0)
				opcount.put(def, cnt+1)
			}
		}
		val mdef = opcount.filter[p1, p2| p2 > 1]
		if (!mdef.empty) {
			error(
				'''The controller «c.name» declares multiple copies of the same operations: «FOR o: mdef.keySet SEPARATOR ","»«o.name»«ENDFOR»''',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ControllerMultipleReferencesToOperation'
			)
		}
		
		
		/* C2 */
		for (i : c.PInterfaces) {
			error(
				c.name + ' is a controller and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'ControllerNoRequiredInterfaces'
			)
		}
		/* C1 */
		if (c.machines.filter[m|m instanceof StateMachine].size === 0) {
			error(
				c.name + ' must have at least one state machine',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ControllerHasOneOrMoreStateMachines'
			)
		}
		/* TODO: C2+C4? */
		if (c.operations.filter[o|!(o instanceof OperationDef) && !(o instanceof OperationRef)].size > 0) {
			error(
				getName(c) + ' cannot declare operations outside interfaces',
				RoboChartPackage.Literals.BASIC_CONTEXT__OPERATIONS,
				'NoOpsOutsideInterfacesInController'
			)
		}

		val pVars = getPVars(c)
		val pOps = getPOps(c)
		val machines = new HashSet<EObject>();
		machines.addAll(c.machines)
		//machinesAndOperations.addAll(c.LOperations)
		
		// nb: ANN operations can't require other operations, so we exclude them from C4/STM8-10 checks
		// TODO: is this correct?
		
		//var opDefs = new HashSet<OperationDef>()
		//for (o: c.LOperations) {
		//	val def = if (o instanceof OperationRef) o.ref else o as OperationDef
			//opDefs.add(def)
		//}
		
     	 val opDefs = c.LOperations.map[opDef].filter(OperationDef).toSet
		
		for (s : machines) {
			
			// We record the current context for tracking the depth of the check (STM8)
			var clist = new ArrayList<Context>
			clist.add(c)
			val stm = if (s instanceof StateMachineRef) s.ref else (s as StateMachineDef)		
				
			/* C3 */
			val rVars = getRVars(s)
			
			val matched = rVars.forall[v1|pVars.exists[v2|v1.name.equals(v2.name) && ((v1.type === null && v2.type === null) ||typeCompatible(v1.type, v2.type))]]
			
			if (!matched) {
//			if (!pVars.containsAll(rVars)) {
				var vs = ""
				var started = false
				for (v : rVars) {
					val contains = pVars.exists[v1|v.name.equals(v1.name) && ((v.type === null && v1.type === null) || typeCompatible(v.type, v1.type))]
					if (!contains) {
						if(started) vs += ', '
						vs += v.name
						started = true
					}
				}
				error(
					c.name + ' does not provide all variables required by ' + getName(s) + ' (missing variables: ' +
						vs + ')',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ControllerProvidesAllVars'
				)
			}
			/* C4 */
			val rOps = getROps(s)
			if (!pOps.containsAll(rOps)) {
				error(
					c.name + ' does not provide all operations required by ' + getName(s),
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ControllerProvidesAllOps'
				)
			}
			
			// Calculate events, variables and clocks available from stm
			val events = new HashSet<Event>
			events.addAll(stm.events)
			stm.interfaces.forEach[i | events.addAll(i.events)]
			 
			val stmpVars = getPVars(stm)
			
			val clocks = new HashSet<Clock>
			clocks.addAll(stm.clocks)
			stm.interfaces.forEach[i | clocks.addAll(i.clocks)]	
						
			/* STM8, STM9 and STM10 checked for opDef in relation to stm. */ 
			for (op : rOps) {
				val opDef = opDefs.findFirst[x|OpEqual(op,x)]
				if (opDef !== null) {
					requiresProvides(c,stm,opDef,stmpVars.toSet,clocks,events)		
				}
			}
		}
		
		/* C4 (weakened)
		 *
		 * All operations required by the controller's state machines, including the machines that define operations,
		 * must be required or defined by the controller. 
		 */
		for (opDef : opDefs) {
			val rOps = getROps(opDef)
			if (rOps !== null) {
				for (op : rOps) {
					if (!pOps.exists[x|OpSigEqual(op,x)]) {
						error(
							'\'' + opDef.name + '\' requires operation \'' + op.name + '\' but controller ' + c.name + ' does not define or require it.',
							RoboChartPackage.Literals.CONTROLLER_DEF__LOPERATIONS,
							'ControllerProvidesAllOps'
						)
					}
				}
			}
			
			val opDefPVars = getPVars(opDef)
			
			val events = new HashSet<Event>
			events.addAll(opDef.events)
			opDef.interfaces.forEach[i | events.addAll(i.events)]
			
			val clocks = new HashSet<Clock>
			clocks.addAll(opDef.clocks)
			opDef.RInterfaces.forEach[i | clocks.addAll(i.clocks)]
			opDef.interfaces.forEach[i | clocks.addAll(i.clocks)]	
			
			for (op : rOps) {
				val requiredOpDef = opDefs.findFirst[x|OpEqual(op,x)]
				if (requiredOpDef !== null) {
					requiresProvides(c,opDef,requiredOpDef,opDefPVars.toSet,clocks,events)		
				}
			}
		}
		
		/* C9 */
		if (c.clocks.size > 0) {
			error(
				getName(c) + ' cannot declare clocks',
				RoboChartPackage.Literals.BASIC_CONTEXT__CLOCKS,
				'NoClocksInController'
			)
		}
		
		/* C10 */
		for (i : c.interfaces) {
			if (i.clocks.size > 0)
				error(
					c.name + ' is a controller and cannot define interface ' + i.name + ' because it contains clocks',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ControllerNoDefinedInterfacesWithClocks'
				)
		}
		
		/* C11 */
		for (i : c.RInterfaces) {
			if (i.clocks.size > 0)
				error(
					c.name + ' is a controller and cannot require interface ' + i.name + ' because it contains clocks',
					RoboChartPackage.Literals.CONTEXT__RINTERFACES,
					'ControllerNoRequiredInterfacesWithClocks'
				)
		}
	}

	def void requiresProvides(NamedElement c,
							  StateMachineBody container, 
							  StateMachineBody stm,
							  Set<Variable> vars, 
							  Set<Clock> clocks,
							  Set<Event> events
	) {

		/* STM8 *
		 *
		 * A state machine that requires an operation, including a machine that defines another operation,
		 * must define, or require all variables required by that operation.
		 */
		var rvars = stm.getRVars
		if (rvars !== null) {
			for (v : rvars) {
				// If it doesn't exist, it's an error
				if (!vars.exists[x|x.name == v.name && typeCompatible(v.type,x.type) && x.modifier == v.modifier]) {
					error(
						'\'' + stm.name + '\' requires variable \'' + v.name + '\' but \'' + container.name + '\' does not provide it.',
						c,
						RoboChartPackage.Literals.CONTROLLER_DEF__MACHINES,
						'StateMachineRequiredVars'
					)
				}
			}
		}
		
		/* STM9
		 * 
		 * A state machine that calls an operation, including a machine that defines another
		 * operation, must define all events defined in that operation.  
		 */
		val revents = new HashSet<Event>
		revents.addAll(stm.events)
		stm.interfaces.forEach[i | revents.addAll(i.events)]
		
		if (revents !== null) {
			for (v : revents) {
				// If it doesn't exist, it's an error
				if (!events.exists[x|x.name == v.name && ((v.type === null && x.type === null) || typeCompatible(v.type,x.type))]) {
					error(
						'\'' + stm.name + '\' uses event \'' + v.name + '\' but \'' + container.name + '\' does not use or define \'' + v.name + '\'.',
						c,
						RoboChartPackage.Literals.CONTROLLER_DEF__MACHINES,
						'StateMachineRequiredVars'
					)
				}
			}
		}

		/* STM10
		 * 
		 * A state machine that calls an operation, including a machine that defines another
		 * operation, must define or require all clocks required by that operation.
		 */
		val rclocks = new HashSet<Clock>
		stm.RInterfaces.forEach[i | rclocks.addAll(i.clocks)]
		
		if (rclocks !== null) {
			for (v : rclocks) {
				// If it doesn't exist, it's an error
				if (!clocks.exists[x|x.name == v.name]) {
					error(
						'\'' + stm.name + '\' requires clock \'' + v.name + '\' but \'' + container.name + '\' does not provide it.',
						c,
						RoboChartPackage.Literals.CONTROLLER_DEF__MACHINES,
						'StateMachineRequiredVars'
					)
				}
			}
		}
	}
	
	def Boolean OpEqual(OperationSig sig, Operation op) {
		val GeneralOperation def = opDef(op)
		if (def === null) return false;
		
		if (!def.name.equals(sig.name)) return false;
		if (sig.parameters.size != def.parameters.size) return false;
		for (var i = 0; i < sig.parameters.size; i++) {
			val par1 = sig.parameters.get(i);
			val par2 = def.parameters.get(i);
			if (!paramEqual(par1, par2)) return false;
		}
		return true;
	}
	
	def Boolean OpSigEqual(OperationSig sig, OperationSig op) {
		if (!op.name.equals(sig.name)) return false;
		if (sig.parameters.size != op.parameters.size) return false;
		for (var i = 0; i < sig.parameters.size; i++) {
			val par1 = sig.parameters.get(i);
			val par2 = op.parameters.get(i);
			if (!paramEqual(par1,par2)) return false;
		}
		return true;
	}	
	
	def paramEqual(Parameter p1, Parameter p2) {
		return p1.name == p2.name && ((p1.type === null && p2.type === null) || typeCompatible(p1.type,p2.type))
	}
	
	/**
	 * Gets the events associated with a context.
	 * 
	 * @param it the context
	 * @return the set of events defined in or used by the context
	 */
	private def Set<Event> contextEvents(Context c) {
		new HashSet<Event>()=>[
			addAll(c.events)
			c.interfaces.forEach[i | addAll(i.events)]
		]
	}
	
	/**
	 * Gets the events associated with an operation.
	 * 
	 * <p>
	 * Not all controllers are contexts (specifically, ANN operation are not
	 * contexts), so we need to handle those cases specially.
	 * </p>
	 * 
	 * @param it the operation
	 * @return the list of events defined in or used by the operation
	 */
	private def Set<Event> operationEvents(GeneralOperation it) {
		switch it {
			ANNOperation : #{}
			OperationDef : contextEvents
		}
	}
	
	/**
	 * Gets the clocks associated with an operation.
	 * 
	 * <p>
	 * Not all controllers are contexts (specifically, ANN operation are not
	 * contexts), so we need to handle those cases specially.
	 * </p>
	 * 
	 * @param it the operation
	 * @return the set of clocks defined in or required or used by the operation
	 */
	private def Set<Clock> operationClocks(GeneralOperation it) {
		switch it {
			ANNOperation : #{}
			OperationDef : contextClocks
		}
	}
	
	private def Set<Clock> contextClocks(Context c) {
		new HashSet<Clock>()=>[
			addAll(c.clocks)
			c.RInterfaces.forEach[i | addAll(i.clocks)]
			c.interfaces.forEach[i | addAll(i.clocks)]
		]
	}

	/* STM1, together with I2 implies STM2 and (because OperationDef is a Context) O1:STM2 */
	@Check
	def stmWFC(StateMachineDef c) {
		for (i : c.PInterfaces) {
			error(
				c.name + ' is a state machine and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'StateMachineNoProvidedInterfaces'
			)
		}
		
		if (c.eContainer instanceof ControllerDef) {

			val operations = new HashSet<OperationDef>();
			val parent = c.eContainer as ControllerDef;
			val pVars = getPVars(c);
			val pOps = getPOps(c);
			c.eAllContents.filter(Call).forEach[x|
				val sig = x.operation;
				val op = parent.LOperations.findFirst[y|OpEqual(sig,y)]
				if (op !== null) {
					if (op instanceof OperationRef) 	
						operations.add(op.ref as OperationDef)
					else operations.add(op as OperationDef)
				} 
			]
			for (s : operations) {
				/* C3 */
				val rVars = getRVars(s)
				if (!rVars.forall[x|pVars.exists[v|x.name == v.name && ((v.type === null && x.type === null) || typeCompatible(v.type,x.type))]]) {
					var vs = ""
					var started = false
					for (v : rVars) {
						if (!pVars.exists[x|x.name == v.name && ((v.type === null && x.type === null) || typeCompatible(v.type,x.type))]) {
							if(started) vs += ', '
							vs += v.name
							started = true
						}
					}
					error(
						c.name + ' does not provide all variables required by call to operation ' + getName(s) + ' (missing variables: ' + vs + ')',
						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
						'ControllerProvidesAllVars'
					)
				}
				/* C4 */
				// In the new compositional semantics this restriction is no longer required,
				// as instead, C4 only applies at the level of a controller.
//				val rOps = getROps(s)
//				if (!pOps.containsAll(rOps)) {
//					error(
//						c.name + ' does not provide all operations required by ' + getName(s),
//						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//						'ControllerProvidesAllOps'
//					)
//				}
				/* STM9 */
				val levents = c.contextEvents
				val revents = s.operationEvents
							
				if (levents !== null) {
					for (v : revents) {
						// If it doesn't exist, it's an error
						if (!levents.exists[x|x.name == v.name && ((v.type === null && x.type === null) || typeCompatible(v.type,x.type))]) {
							error(
								'\'' + s.name + '\' uses event \'' + v.name + '\' but \'' + c.name + '\' does not use or define \'' + v.name + '\'.',
								c,
								RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
								'StateMachineOperationUsesEvents'
							)
						}
					}
				}
				
				/* STM10 */
				val rclocks = s.RInterfaces?.flatMap[clocks]?.toSet
				val clocks = c.contextClocks
				
				if (rclocks !== null) {
					for (v : rclocks) {
						// If it doesn't exist, it's an error
						if (!clocks.exists[x|x.name == v.name]) {
							error(
								'\'' + s.name + '\' requires clock \'' + v.name + '\' but \'' + c.name + '\' does not provide it.',
								c,
								RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
								'StateMachineRequiredClocks'
							)
						}
					}
				}			
			}
			
		}
		
		/* STM7 */
		for (i : c.RInterfaces) {
			if (i.clocks.size > 0)
				error(
					c.name + ' is a state machine and cannot require interface ' + i.name + ' because it contains clocks',
					RoboChartPackage.Literals.CONTEXT__RINTERFACES,
					'StateMachineNoRequiredInterfacesWithClocks'
				)
		}
		
	}
	
	@Check
	def stmRefWFC(StateMachineRef c) {
		if (c.eContainer instanceof ControllerDef) {
			val operations = new HashSet<OperationDef>();
			val parent = c.eContainer as ControllerDef;
			val pVars = getPVars(c);
			val pOps = getPOps(c);
			c.ref.eAllContents.filter(Call).forEach[x|
				val sig = x.operation;
				val op = parent.LOperations.findFirst[y|OpEqual(sig,y)]
				if (op !== null) {
					if (op instanceof OperationRef) 	
						operations.add(op.ref as OperationDef)
					else operations.add(op as OperationDef)
				} 
			]
			for (s : operations) {
				/* C3 */
				val rVars = getRVars(s)
				if (!rVars.forall[x|pVars.exists[v|x.name == v.name && ((v.type === null && x.type === null) || typeCompatible(v.type,x.type))]]) {
					var vs = ""
					var started = false
					for (v : rVars) {
						if (!pVars.exists[x|x.name == v.name && ((v.type === null && x.type === null) || typeCompatible(v.type,x.type))]) {
							if(started) vs += ', '
							vs += v.name
							started = true
						}
					}
					error(
						c.name + ' in the context of the controller ' + parent.name + ' does not provide all variables required by call to operation ' + getName(s) + ' (missing variables: ' + vs + ')',
						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
						'ControllerProvidesAllVars'
					)
				}
				/* C4 */
//				val rOps = getROps(s)
//				if (!pOps.containsAll(rOps)) {
//					error(
//						c.name + ' in the context of the controller ' + parent.name + ' does not provide all operations required by ' + getName(s),
//						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//						'ControllerProvidesAllOps'
//					)
//				}			
			}
		}
	}

	def List<Variable> getPVars(EObject o) {
		if (o instanceof RoboticPlatformDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.PInterfaces.forEach [ i |
				i.variableList.forEach [ l |
					pVars.addAll(l.vars)
				]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			return pVars
		} else if (o instanceof RoboticPlatformRef) {
			return getPVars(o.ref)
		} else if (o instanceof ControllerDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			// any controller required variable is provided to the state machines
			return pVars
		} else if (o instanceof ControllerRef) {
			return getPVars(o.ref)
		} else if (o instanceof StateMachineDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			return pVars
		} else if (o instanceof OperationDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			return pVars
		} else if (o instanceof StateMachineRef) {
			return getPVars(o.ref)
		}
	}

	def List<OperationSig> getPOps(EObject o) {
		if (o instanceof RoboticPlatformDef) {
			val pOps = new LinkedList<OperationSig>()
			pOps.addAll(o.operations)
			o.PInterfaces.forEach[i|pOps.addAll(i.operations)]
			return pOps
		} else if (o instanceof RoboticPlatformRef) {
			return getPOps(o.ref)
		} else if (o instanceof ControllerDef) {
			val pOps = new LinkedList<OperationSig>()

			// TODO: review this case as it involves operation definitions
			o.LOperations.filter[m|m instanceof OperationDef || m instanceof OperationRef].forEach [ m |
				if(m instanceof OperationRef) pOps.add(m.ref) else pOps.add(m as OperationSig)
			]
			// any controller required operation is provided to the state machines
			o.RInterfaces.forEach[i|pOps.addAll(i.operations)]
			// any operation defined inside a controller, is provided to the state machines
			return pOps
		} else if (o instanceof ControllerRef) {
			return getPOps(o.ref)
		} else if (o instanceof StateMachineDef) {
			// any state machine required operation is provided to the state machine behaviours
			val pOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|pOps.addAll(i.operations)]
			return pOps
		} else if (o instanceof StateMachineRef) {
			return getPOps(o.ref)
		}
	}

	def List<Variable> getRVars(EObject o) {
		if (o instanceof RoboticPlatform) {
			throw new RuntimeException(
				"Robotic Platform do not require variables, therefore this call should not happen")
		} else if (o instanceof ControllerDef) {
			val rVars = new LinkedList<Variable>()
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|rVars.addAll(l.vars)]
			]
			return rVars
		} else if (o instanceof ControllerRef) {
			return getRVars(o.ref)
		} else if (o instanceof StateMachineDef) {
			val rVars = new LinkedList<Variable>()
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|rVars.addAll(l.vars)]
			]
			return rVars
		} else if (o instanceof StateMachineRef) {
			return getRVars(o.ref)
		} else if (o instanceof OperationDef) {
			val rVars = new LinkedList<Variable>()
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|rVars.addAll(l.vars)]
			]
			return rVars
		} else if (o instanceof OperationRef) {
			return getRVars(o.ref)
		}
	}

	def List<OperationSig> getROps(EObject o) {
		if (o instanceof RoboticPlatform) {
			throw new RuntimeException(
				"Robotic Platform do not require variables, therefore this call should not happen")
		} else if (o instanceof ControllerDef) {
			val rOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|rOps.addAll(i.operations)]
			return rOps
		} else if (o instanceof ControllerRef) {
			return getROps(o.ref)
		} else if (o instanceof StateMachineDef) {
			val rOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|rOps.addAll(i.operations)]
			return rOps
		} else if (o instanceof StateMachineRef) {
			return getROps(o.ref)
		} else if (o instanceof OperationDef) {
			val rOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|rOps.addAll(i.operations)]
			return rOps
		} else if (o instanceof OperationRef) {
			return getROps(o.ref)
		}
	}

	@Check
	def moduleWFC(RCModule m) {
		/* M1 */
		val rp = m.nodes.findFirst[n|n instanceof RoboticPlatform]
		if (rp === null || m.nodes.filter[n|n instanceof RoboticPlatform].size > 1) {
			error(
				m.name + ' must have exactly one robotic platform',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'NotUniqueRoboticPlatform'
			)
		}

		if (m.nodes.filter[x|x instanceof Controller].size === 0) {
			error(
				m.name + ' must have at least one controller',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ModuleHasOneOrMoreControllers'
			)
		}

		if (m.nodes.filter[x|x instanceof StateMachine].size > 0) {
			error(
				m.name + ' must not have a state machine outside a controller',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ModuleHasNoStateMachines'
			)
		}

		/* M2 */
		// need to update checkRequiredVariables with type comparison when type checker is working
		val pVars = getPVars(rp)
		val pOps = getPOps(rp)
		for (c : m.nodes.filter[n|n instanceof Controller]) {
			val rVars = getRVars(c)
			
			val matched = rVars.forall[v1|pVars.exists[v2|v1.name.equals(v2.name) && ((v1.type === null && v2.type === null) || typeCompatible(v1.type, v2.type))]]
			
			if (!matched) {
//			if (!pVars.containsAll(rVars)) {
				var s = ""
				var started = false
				for (v : rVars) {
					val contains = pVars.exists[v1|v.name.equals(v1.name) && ((v.type === null && v1.type === null) || typeCompatible(v.type, v1.type))]
					if (!contains) {
						if(started) s += ', '
						s += v.name
						started = true
					}
				}
				error(
					m.name + ' does not provide all variables required by ' + getName(c) + '(missing variables: ' + s +
						')',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ModuleProvidesAllVars'
				)
			}
			val rOps = getROps(c)
			if (!pOps.containsAll(rOps)) {
				error(
					m.name + ' does not provide all operations required by ' + getName(c),
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ControllerProvidesAllOps'
				)
			}
		}
	}

	/* I2 */
	@Check
	def interfaceEitherEventsOrOthers(Interface d) {
		if (d.events.size > 0 && d.operations.size > 0) {
			error(
				'Aside from variables, an interface should have either events or operations',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'InterfaceEitherEventsOrOthers'
			)
		}
	}

	def getName(EObject o) {
		if (o instanceof ControllerDef)
			o.name
		else if (o instanceof ControllerRef)
			o.ref.name
		else if (o instanceof StateMachineDef)
			o.name
		else if (o instanceof StateMachineRef)
			o.ref.name
		else if(o instanceof NamedElement) o.name else null
	}

	/* I1 */
	@Check
	def interfaceEitherEventsOrOthers(Context d) {
		for (Interface i : d.RInterfaces) {
			if (i.events.size > 0)
				error(
					getName(d) + ' cannot require interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__RINTERFACES,
					'RequiredInterfaceWithoutEvents'
				)
		}
		for (Interface i : d.PInterfaces) {
			if (i.events.size > 0)
				error(
					getName(d) + ' cannot provide interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__PINTERFACES,
					'ProvidedInterfaceWithoutEvents'
				)
		}
	}

	// Timed validation rules
//	@Check
//	def clockExpComparedWithWithCall(CallExp e) {
//		if (e.eContainer !== null) {
//			
//		}
//	}
//	
//	def boolean isClockExp(Expression e) {
//		switch e {
//			Plus: 	e.left.isClockExp && e.right.isClockExp
//			Minus: 	e.left.isClockExp && e.right.isClockExp
//			Mult: 	e.left.isClockExp && e.right.isClockExp
//			Div:	 e.left.isClockExp && e.right.isClockExp
//			Modulus : e.left.isClockExp && e.right.isClockExp
//		}
//	}
//	
//	def dispatch boolean isParentComparisonWithClock(Expression e) {
//		switch e {
//			GreaterThan : e.left.isClockExp || e.right.isClockExp
//			default : e.eContainer.isParentComparisonWithClock
//		}
//	}
//	
//	def dispatch boolean isParentComparisonWithClock(EObject e) {
//		return false
//	}

	/* TT1 */
	@Check
	def checkTransitionDeadline(Transition e) {
		if (e.deadline !== null) {
			if (e.trigger === null) {
				error(
					'Transition '+e.name+' has a deadline but no trigger.',
					RoboChartPackage.Literals.TRANSITION__DEADLINE,
					'TransitionDeadlineError', 'timed'
				)
			}
		}
	}

	/* Helper for TE4 */
	def boolean isConstantExp(Expression e) {
		switch e {
			RefExp: {
				var n = e.ref
				return switch n {
					Variable: {
						(n.modifier === VariableModifier.CONST)
					}
					Literal:
						true
					default:
						false
				}
			}
			IntegerExp:
				true
			CallExp: {
				var isConstant = true
				for (arg : e.args) {
					isConstant = isConstant && arg.isConstantExp
				}
				return isConstant
			}
			Plus:
				e.left.isConstantExp && e.right.isConstantExp
			Minus:
				e.left.isConstantExp && e.right.isConstantExp
			Mult:
				e.left.isConstantExp && e.right.isConstantExp
			Div:
				e.left.isConstantExp && e.right.isConstantExp
			Modulus:
				e.left.isConstantExp && e.right.isConstantExp
			ArrayExp:
				e.value.isConstantExp
			ParExp:
				e.exp.isConstantExp
			default:
				false
		}
	}

	/* SCE2, covers TE4 for sinceEntry(state) */
	@Check
	def clockExpOnlySupportedComparator(StateClockExp e) {
		checkClockExpWellTyped(e)
		//clockExpOnlySupported(e)
		// No longer needed in revised form of TE4
	}

	/* CE2, covers TE4 for since(clock) */
	@Check
	def clockExpOnlySupportedComparator(ClockExp e) {
		checkClockExpWellTyped(e)
		//clockExpOnlySupported(e)
		// No longer needed in revised form of TE4 
	}
	
	/* TE5 (helper) */
	def Transition identifyContainingTransition(EObject obj) {
		if (obj.eContainer instanceof Expression) {
			identifyContainingTransition(obj.eContainer)
		} else if (obj.eContainer instanceof Transition) {
			return obj.eContainer as Transition
		} else {
			return null
		}
	}
	
	/* TE5 */
	@Check
	def checkSinceEntryLevel(StateClockExp e) {
		val transition = identifyContainingTransition(e)
		if (transition !== null && e.state !== null) {
			if (transition.eContainer != e.state.eContainer) {
				error('sinceEntry('+e.state.name+') refers to a state not contained by the same NodeContainer',
					RoboChartPackage.Literals.STATE_CLOCK_EXP__STATE,
					'StateClockExpError',
					'timed'
				)
			}
		}
	}

	/* TE4 (helper) */
	def checkClockExpWellTyped(Expression e) {
		val nat = getNatType(e)
		val real = getRealType(e)

		if (e.eContainer !== null && e.eContainer instanceof Expression) {
			var parent = e.eContainer
			var isTypeCompatible = false

			switch parent {
				LessThan: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				LessOrEqual: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				GreaterThan: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				GreaterOrEqual: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				Equals: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				default:
					error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
			}
			if (!isTypeCompatible) {
				error('Timed expression being compared should be of type nat or real', null, 'TimeExpressionTypeError',
					'timed')
			}
		} else {
			error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
		}
	}

	/* TE4 (part for checking comparison to constant) */
	def clockExpOnlySupported(Expression e) {
		if (e.eContainer !== null && e.eContainer instanceof Expression) {
			var parent = e.eContainer
			var isconstant = false
			switch parent {
				LessThan: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				LessOrEqual: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				GreaterThan: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				GreaterOrEqual: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				Equals: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				default:
					error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
			}
			if (!isconstant) {
				warning('Timed expression is not constant', null, 'TimeExpressionNotConstant', 'timed')
			}
		} else {
			error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
		}
	}

	/* TE1' (covers "TE1: since and sinceEntry only in transition guards" and CE1/SCE1) */
	// Expressions such as
	@Check
	def statementNoTimedExpressions(Expression e) {
		if (e !== null && (e instanceof ClockExp || e instanceof StateClockExp) && e.expressionInStatement) {
			error('Timed expression not allowed in action', null)
		}
	}

	def dispatch boolean expressionInStatement(Statement s) {
		return true
	}

	def dispatch boolean expressionInStatement(EObject obj) {
		if (obj.eContainer !== null) {
			return expressionInStatement(obj.eContainer)
		} else {
			return false
		}
	}
	
	/* TE2 */
	@Check
	def wfcTE2_NoForeignClock(ClockExp ce) {
		val stm = identifyContainingStateMachineBody(ce)
		if (stm instanceof StateMachineDef && !stm.clocks.contains(ce.clock) && !stm.interfaces.exists[i|i.clocks.contains(ce.clock)]) {
			error("TE2: The clock in " + print(ce) 
				+ " is not declared within state machine " + stm.name,
			 	RoboChartPackage.Literals.CLOCK_EXP__CLOCK,
			 	"NoForeignClock"
			)
		}
	}

	/* Helper for TE3 (termination requires on absence of loops in node hierarchy) */
	def BasicEList<circus.robocalc.robochart.State> identifyNestedStates(NodeContainer nc) {
		val nestedStates = new BasicEList<circus.robocalc.robochart.State>
		for (n : nc.nodes) {
			if (n instanceof circus.robocalc.robochart.State) {
				nestedStates.addAll(identifyNestedStates(n as NodeContainer))
			 	nestedStates.add(n as circus.robocalc.robochart.State)
		 	}
	 	} 
		nestedStates
	}

	/* TE3 */
	@Check
	def wfcTE3_NoForeignState(StateClockExp sce) {
		val stm =  identifyContainingStateMachineBody(sce)
		val nestedStates = identifyNestedStates(stm)
		
		if (sce.state instanceof Final) {
			error("TE3: The state in " + print(sce) 
				+ " cannot be a final state",
			 	RoboChartPackage.Literals.STATE_CLOCK_EXP__STATE,
			 	"NoFinalStateInStateClockExp"
			)
		}
		
		if (sce.state !== null && !nestedStates.contains(sce.state)) {
			error("TE3: The state in " + print(sce) 
				+ " is not declared within state machine " + stm.name,
			 	RoboChartPackage.Literals.STATE_CLOCK_EXP__STATE,
			 	"NoForeignState"
			)
		}
	}
	
	@Check
	def wfcCn_EventsFromSameContext(Connection c) {
		var cont = c.eContainer
		/* Cn1 (approximation via to/from) */
		if (cont instanceof RCModule) {
			if (!(cont.nodes.contains(c.to) && cont.nodes.contains(c.from))) {
				error('Cn1: Connections of a module must associate only its robotic platform and its controllers',
					RoboChartPackage.Literals.CONNECTION__EFROM, 
					'NodesNotFromSameModule')
			}
		}
			
		/* Cn3 (approximation via to/from) */
		if (cont instanceof ControllerDef) {
			var nodes = new LinkedList<ConnectionNode>
			nodes.add(cont) 
			nodes.addAll(cont.machines)
			if (!(nodes.contains(c.to) && nodes.contains(c.from))) {
				error('Cn3: Connections of a controller must associate only itself and its state machines',
					RoboChartPackage.Literals.CONNECTION__EFROM, 
					'NodesNotFromSameController')
			}
		}
		 
		/* Cn10 */
		// identify context and collect set of events of this context for to/from
		val toEvents = new LinkedList<Event>()
		toEvents.addAll(getContext(c.to).events)
		getContext(c.to).interfaces.forEach[i | toEvents.addAll(i.events)]
		// check whether eto is in this list
		if (!toEvents.contains(c.eto)) {
			error('Cn10: The eto-event of a connection must be an event of its to-node',
				RoboChartPackage.Literals.CONNECTION__ETO, 
				'ToEventFromForeignContext')
		}
		val fromEvents = new LinkedList<Event>()
		fromEvents.addAll(getContext(c.from).events)
		getContext(c.from).interfaces.forEach[i | fromEvents.addAll(i.events)]
		// check whether efrom is in this list
		if (!fromEvents.contains(c.efrom)) {
			error('Cn10: The efrom-event of a connection must be an event of its from-node',
				RoboChartPackage.Literals.CONNECTION__EFROM, 
				'FromEventFromForeignContext')
		}
		
		/* Cn11 */
		val from = c.from
		val to = c.to
		if (from instanceof StateMachine && to instanceof StateMachine) {
			if (c.async) {
				warning('Asynchronous connections currently have no semantics implemented. See:
https://github.com/UoY-RoboStar/robochart-csp-gen/issues/39',
				RoboChartPackage.Literals.CONNECTION__ASYNC, 
				'Cn11')
			}
		}
	}

	@Check
	def rpConnectionAsync(Connection c) {
		// if either end of the connection is a robotic platform,
		// the connections is asynchronous, but it should not be
		// marked as such
		/* Cn2 */
		if (c.to instanceof RoboticPlatform || c.from instanceof RoboticPlatform) {
			val rp = if(c.to instanceof RoboticPlatform) c.to else c.from
			val msg = 'The connection between event ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name +
				' on ' + getName(rp) + '  must be asynchronous'
			if (!c.async) {
				error(msg, RoboChartPackage.Literals.CONNECTION__ASYNC, 'RPConnectionAsync')
			}
		}
		if ((c.from instanceof StateMachine && c.to instanceof StateMachine) || (c.from instanceof Controller &&
			c.to instanceof Controller)) {
			if (c.eto.isBroadcast || c.efrom.isBroadcast) {
				error('A connection of broadcast events should be a relay between different constructs',
					RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionBroadcasstNotRelay')
			}
		}
		/* Cn4 */
		if (c.efrom.broadcast !== c.eto.broadcast) {
			error(
				'Connected events must be both broadcast, or both non-broadcast events',
				RoboChartPackage.Literals.CONNECTION__EFROM,
				'RPConnectionBroadcast'
			)
		}
		if (c.efrom.type !== null && c.eto.type !== null && !typeCompatible(c.efrom.type, c.eto.type)) {
			val msg = 'The events ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name + ' on ' +
				getName(c.to) + ' have incompatible types'
			error(msg, RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionIncompatibleType')
		} else if (c.efrom.type === null && c.eto.type !== null) {
			val msg = 'The events ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name + ' on ' +
				getName(c.to) + ' have incompatible types'
			error(msg, RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionIncompatibleType')
		} else if (c.efrom.type !== null && c.eto.type === null) {
			val msg = 'The events ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name + ' on ' +
				getName(c.to) + ' have incompatible types'
			error(msg, RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionIncompatibleType')
		}
	}

	/* RP3, I3, C5, STM5, O1:STM5 */
	@Check(CheckType.FAST)
	def checkUniqueness(NamedElement o) {
		val uri = o.eResource.URI
		// This is to avoid trying to get a segment of a __synthetic file.
		if (uri.segmentCount <= 1) return;
		val project = uri.segment(1)
		val c = new LinkedList<IEObjectDescription>()
		val qn = qnp.getFullyQualifiedName(o)
		rds.allResourceDescriptions.filter[rd|rd.URI.segment(1) === project].forEach [ rd |
			c.addAll(rd.getExportedObjects(o.eClass, qn, false).toList)
		]
		val s = c.size
		if (s > 1) {
			warning(
				qn.toString("::") + ' is not unique',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'UniqueQualifiedName'
			)
		}
	}

	@Check
	def variableInitWellTyped(Variable v) {
		if (v.initial !== null) {
			val t1 = v.initial.typeFor
			val t2 = v.type
			if (!typeCompatible(t1, t2)) {
				val parent = if (v.eContainer.eContainer instanceof NamedElement)
						(v.eContainer.eContainer as NamedElement).
							name
					else
						null
				val msg = '''Variable «v.name» «(if(parent !== null) 'in ' + parent else '')» expects type «v.type.printType», but «IF t1 === null»expression cannot be typed.«ELSE»expression has type «t1.printType»«ENDIF»'''

				error(
					msg,
					RoboChartPackage.Literals.VARIABLE__INITIAL,
					'VarInitType'
				)
			}
		}
	}

//	def dispatch String print(Assignable a) {
//		switch (a) {
//			VarRef:
//				return a.name.name
//			VarSelection:
//				return (a.receiver.print + "." + a.member.name)
//			ArrayAssignable: {
//				var s = a.value.print + "["
//				if (a.parameters.size > 0) {
//					s += a.parameters.get(0).print
//					for (var i = 1; i < a.parameters.size; i++) {
//						s += ", " + a.parameters.get(i).print
//					}
//				}
//				s += "]"
//				return s
//			}
//		}
//	}
	@Check
	def assignmentWellTyped(Assignment a) {
		val t2 = a.left.typeFor
		val t1 = a.right.typeFor
		if (!typeCompatible(t1, t2)) { // && t1 !==	null) { I had to remove this otherwise an badly typed expression would not yield an error
			val msg = '''Variable «a.left.print» expects type «a.left.typeFor.printType», but «IF t1 === null»expression cannot be typed.«ELSE»expression has type «t1.printType»«ENDIF» '''
			error(
				msg,
				RoboChartPackage.Literals.ASSIGNMENT__LEFT,
				'AssignmentTypeError'
			)
		}
	}

	@Check
	def ifStmtWellTyped(IfStmt ifstmt) {
		val bool = getBooleanType(ifstmt)
		val tcond = ifstmt.expression.typeFor
		if (!typeCompatible(tcond, bool)) {
			val msg = 'Condition of if statement should have type boolean, but ' +
				if(tcond === null) 'actual type could not be computed' else 'actual type is ' + tcond.printType
			error(
				msg,
				RoboChartPackage.Literals.IF_STMT__EXPRESSION,
				'IfStmtTypeError'
			)
		}
	}

	@Check
	def waitWellTyped(Wait w) {
		val integer = getIntType(w)
		val setInt = RoboChartFactory.eINSTANCE.createSetType
		setInt.domain = EcoreUtil2.copy(integer)
		val t = w.duration.typeFor
		if (!typeCompatible(t, integer) && !typeCompatible(t, setInt)) {
			error(
				'Parameter of wait should be an integer or a set of integers',
				RoboChartPackage.Literals.WAIT__DURATION,
				'WaitTypeError'
			)
		}
	}

	@Check
	def callWellTyped(Call c) {
		val op = c.operation
		val opSig = if(op instanceof OperationRef) op.ref as OperationSig else op as OperationSig
		if (opSig.parameters.size !== c.args.size) {
			error(
				'Incorrect number of parameters in operation call',
				RoboChartPackage.Literals.CALL__ARGS,
				'OperationWrongNumberofParameters'
			)
		} else {
			for (var i = 0; i < opSig.parameters.size; i++) {
				val argtype = c.args.get(i).typeFor
				if (!typeCompatible(argtype, opSig.parameters.get(i).type)) {
					error(
						'Parameter ' + i + ' of the operation ' + opSig.name + ' expects type ' +
							opSig.parameters.get(i).type.printType + ', but argument has type ' + argtype.printType,
						RoboChartPackage.Literals.CALL__ARGS,
						'CallArgumentTypeError'
					)
				}
			}
		}
	}

//	@Check
//	def sendEventWFC(SendEvent s) {
////		if (s.trigger.reset !== null && s.trigger.reset.length > 0) {
////			error('A send action cannot have a reset associated with it', RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
////				'NoResetInSendEvent');
////		}
////		if (s.trigger._type === CommunicationType.EMPTY) {
////			error('A send action cannot have an empty trigger', RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
////				'NoEmptyTriggerInSendEvent');
////		}
//	}

	@Check
	def communicationWellTyped(Communication t) {
		/* Tg1 */
		// Violation is currently not possible because the syntax (editors) doesn't allow the creation of such objects
		if (t._type === CommunicationType.SIMPLE) {
			if (t.parameter !== null) {
				error(
					'A simple communication should not specify a parameter attribute',
					RoboChartPackage.Literals.COMMUNICATION__PARAMETER,
					'NoParametersForSimpleTriggers'
				)							
			}
			if (t.value !== null) {
				error(
					'A simple communication should not specify a value attribute',
					RoboChartPackage.Literals.COMMUNICATION__VALUE,
					'NoValueForSimpleTriggers'
				)							
			}
		}
		/* Tg5 */
		if ((t._type === CommunicationType.INPUT || t._type === CommunicationType.OUTPUT || t._type === CommunicationType.SYNC) &&
			t.event.type === null) {
			error(
				'An input, output or sync communication must refer to a typed event. See ' + t.event.name,
				RoboChartPackage.Literals.COMMUNICATION__EVENT,
				'TypedEventRequired'
			)
		}
		/* Tg2 */
		if ((t._type === CommunicationType.SIMPLE) && t.event.type !== null) {
			error(
				'A simple communication must refer to an untyped event. See ' + t.event.name,
				RoboChartPackage.Literals.COMMUNICATION__EVENT,
				'UntypedEventRequired'
			)
		}
		/* Tg3 */
		if (t._type === CommunicationType.INPUT && (t.parameter === null || t.value !== null)) {
			error(
				'An input communication must have a parameter, not a value',
				RoboChartPackage.Literals.COMMUNICATION__EVENT,
				'InputParameterError'
			)
		}
		/* Tg4 */
		if (t._type === CommunicationType.OUTPUT && (t.parameter !== null || t.value === null)) {
			error(
				'An output communication must have a value, not a parameter',
				RoboChartPackage.Literals.COMMUNICATION__EVENT,
				'OutputParameterError'
			)
		}
		/* Tg4 */
		if (t._type === CommunicationType.SYNC && (t.parameter !== null || t.value === null)) {
			error(
				'An synchronisation communication must have a value, not a parameter',
				RoboChartPackage.Literals.COMMUNICATION__EVENT,
				'SyncParameterError'
			)
		}

		if (t._type === CommunicationType.INPUT) {
			val t1 = t.parameter.type
			val t2 = t.event.type
			if (!typeCompatible(t1, t2)) {
				error(
					'Event ' + t.event.name + ' expects type ' + t2.printType + ', but input parameter has type ' +
						t1.printType,
					RoboChartPackage.Literals.COMMUNICATION__PARAMETER,
					'InputCommunicationTypeError'
				)
			}
		} else if (t._type === CommunicationType.OUTPUT) {
			val t1 = t.value.typeFor
			val t2 = t.event.type
			if (!typeCompatible(t1, t2)) {
				error(
					'Event ' + t.event.name + ' expects type ' + t2.printType + ', but output value has type ' +
						t1.printType,
					RoboChartPackage.Literals.COMMUNICATION__VALUE,
					'OutputCommunicationTypeError'
				)
			}
		} else if (t._type === CommunicationType.SYNC) {
			val t1 = t.value.typeFor
			val t2 = t.event.type
			if (!typeCompatible(t1, t2)) {
				error(
					'Event ' + t.event.name + ' expects type ' + t2.printType +
						', but synchronisation value has type ' + t1.printType,
					RoboChartPackage.Literals.COMMUNICATION__VALUE,
					'SyncCommunicationTypeError'
				)
			}
		} else if (t._type === CommunicationType.SIMPLE) {
			if (t.event.type !== null) {
				error(
					'Event ' + t.event.name + ' expects a value of type ' + t.event.type.printType,
					RoboChartPackage.Literals.COMMUNICATION__EVENT,
					'SimpleCommunicationTypeError'
				)
			}
		}
	}

	@Check
	def transitionWellTyped(Transition t) {
		val bool = getBooleanType(t)
		val tcond = t.condition?.typeFor
		if (t.condition !== null && !typeCompatible(tcond, bool)) {
			val msg = 'Transition condition should have type boolean, but ' + (if (tcond === null)
				'actual type could not be computed'
			else
				'actual type is ' + tcond.printType)
			error(
				msg,
				RoboChartPackage.Literals.TRANSITION__CONDITION,
				'TransitionConditionTypeError'
			)
		}
	}

	@Check
	def constantWellTyped(RefExp e) {
		if (e.ref instanceof Literal && !(e.eContainer instanceof CallExp)) {
			val c = e.ref as Literal
			if (c.types.size > 0) {
				error(
					"Constant " + c.name + " expects " + c.types.size + " arguments, but call provides none",
					RoboChartPackage.Literals.REF_EXP__REF,
					'IncorrectNumberOfArguments'
				)
				return
			}
		}
	}

	@Check
	def constantConstructionWellTyped(CallExp e) {
		val t = e.function.typeFor
		if (t instanceof TypeRef && (t as TypeRef).ref instanceof Enumeration) {
			val variant = (e.function as RefExp).ref as Literal // a variant is interpreted as a constructor function
			if (variant.types.size === 0) {
				warning(
					"Constructor " + variant.name + " has no parameter. Avoid using a call.",
					RoboChartPackage.Literals.CALL_EXP__FUNCTION,
					'ParameterlessConstructorWithCall'
				)
				return;
			}

			if (variant.types.size !== e.args.size) // wrong number of parameters
			{
				error(
					"Constructor " + variant.name + " expects " + variant.types.size +
						" arguments, but call only provides " + e.args.size,
					RoboChartPackage.Literals.CALL_EXP__FUNCTION,
					'IncorrectNumberOfArguments'
				)
				return;
			}
			val res = e.eResource
			for (var i = 0; i < variant.types.size; i++) {
				var type = variant.types.get(i)

				type = type.rewriteType(res)
				var exp_type = e.args.get(i).typeFor
				exp_type = exp_type.rewriteType(res)
				if (exp_type === null) // one of the parameters cannot be typed
				{
					error(
						"Parameter " + (i + 1) + " of the constructor " + variant.name + " could not be typed",
						RoboChartPackage.Literals.CALL_EXP__FUNCTION,
						'ParameterWithoutType'
					)
					return;
				}

				if (!typeCompatible(exp_type, type)) // one of the parameters has the wrong type
				{
					error(
						"Parameter " + (i + 1) + " of the constructor " + variant.name + " should have type " +
							type.printType + ", but the received value has type " + exp_type.printType,
						RoboChartPackage.Literals.CALL_EXP__FUNCTION,
						'WrontParameterType'
					)
					return;
				}
			}
		}
	}

	@Check
	def functionCallWellTyped(CallExp e) {
		if (e.function instanceof Expression) {
			val t = e.function.typeFor
			if (t instanceof FunctionType) {
				if (t.domain instanceof ProductType) {
					val p = t.domain as ProductType
					if (p.types.size !== e.args.size) {
						val f = e.function.print
						error(
							"Function " + f + " expects  " + p.types.size + " arguments, but call only provides " +
								e.args.size,
							RoboChartPackage.Literals.CALL_EXP__ARGS,
							'IncorrectNumberOfArguments'
						)
						return;
					}
					for (var i = 0; i < p.types.size; i++) {
						val t1 = e.args.get(i).typeFor
						val t2 = p.types.get(i)
						if (!typeCompatible(t1, t2) && t1 !== null) {
							val arg = e.args.get(i).print()
							val f = e.function.print()
							error(
								"Argument " + arg + " of function " + f + " has type " + t1.printType +
									": expected type is " + t2.printType,
								RoboChartPackage.Literals.CALL_EXP__ARGS,
								'UndefinedTypeInArguments'
							)
						}
					}
				} else if (e.args.size === 1) {
					val t1 = e.args.get(0).typeFor
					val t2 = t.domain
					val u = unify(t2, t1)
					val aux = instantiate(t2, u)
					if (!typeCompatible(t1, aux)) {
						val arg = e.args.get(0).print()
						val f = e.function.print()
						error(
							"Argument " + arg + " of function " + f + " has type " + t1.printType +
								": expected type is " + aux.printType,
							RoboChartPackage.Literals.CALL_EXP__ARGS,
							'UndefinedTypeInArguments'
						)
					}
				}
			}
		}
	}

	@Check
	def BroadcastConnectionWFC(Connection c) {
		// only one of the extremities are broadcasts
		if ((c.efrom.broadcast || c.eto.broadcast) && !(c.efrom.broadcast && c.eto.broadcast)) {
			if (!c.efrom.broadcast) {
				error("A broadcast event must be connected to another broadcast event. See " + c.efrom.name + " in " +
					c.from.name, RoboChartPackage.Literals.CONNECTION__EFROM, "Broadcast2NonBroadcast");
			} else if (!c.eto.broadcast) {
				error("A broadcast event must be connected to another broadcast event. See " + c.eto.name + " in " +
					c.to.name, RoboChartPackage.Literals.CONNECTION__ETO, "Broadcast2NonBroadcast");
			}
		}
	}

	@Check
	def moduleOneConnPerEvent(RCModule mod) {
		var eventConn = new HashMap<String, Connection>()

		/* M3 */
		for (conn : mod.connections) {
			val from = qnp.getFullyQualifiedName(conn.from)+"."+conn.efrom.name;
			val to = qnp.getFullyQualifiedName(conn.to)+"."+conn.eto.name;
			if (eventConn.containsKey(from)) {
				error(
					conn.efrom.name + " on " + conn.from.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__EFROM
				)
				eventConn.put(from, conn)
			}

			if (eventConn.containsKey(to)) {
				error(
					conn.eto.name + " on " + conn.to.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__ETO
				)
			} else {
				eventConn.put(to, conn)
			}
		}
	}

	/* C6 */
	@Check
	def controllerOneConnPerEvent(ControllerDef ctrl) {
		var eventConn = new HashMap<String, Connection>()

		for (conn : ctrl.connections) {
			val from = qnp.getFullyQualifiedName(conn.from)+"."+conn.efrom.name;
			val to = qnp.getFullyQualifiedName(conn.to)+"."+conn.eto.name;
//			System.out.println(qnp.getFullyQualifiedName(conn.from));
//			System.out.println(qnp.getFullyQualifiedName(conn.efrom));
//			System.out.println(from);
//			System.out.println(to);
			if (eventConn.containsKey(from)) {
				error(
					conn.efrom.name + " on " + conn.from.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__EFROM
				)
			} else {
				eventConn.put(from, conn)
			}

			if (eventConn.containsKey(to)) {
				error(
					conn.eto.name + " on " + conn.to.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__ETO
				)
			} else {
				eventConn.put(to, conn)
			}
		}
	}
	
	/* C7 */
	/* Currently not allowed by the meta-model, hence, ineffective. */
	@Check
	def wfcC7_noOpDeclInCtr(ControllerDef c) {
		if (!c.getOperations().isEmpty()) {
			error(
				"C7: Operations must not be declared directly in a controller, but may be defined in the controller",
				c,
				RoboChartPackage.Literals.BASIC_CONTEXT__OPERATIONS 
			)
		}
	}
	//Assumes that the context is a ControllerDef
	//Assumes that the required operations are OperationDef
	def HashSet<OperationDef> stmRequiredOpDefs(StateMachineBody stm, Controller context) {
		val stmOps = getROps(stm)
		val ctrlOps = (ctrlDef(context) as ControllerDef).LOperations
		
		var opDefSet = new HashSet()
		for (stmOp : stmOps) {
			for (ctrlOp : ctrlOps) {
				if (OpEqual(stmOp, ctrlOp)) {
					val opDef = if (ctrlOp instanceof OperationRef) ctrlOp.ref as OperationDef else ctrlOp as OperationDef
					opDefSet.add(opDef)
				}
			}
		}
		opDefSet
	}
	
	// recursively collects outputs of a node container, avoiding operations already checked
	// it is required by WFC O2 that operations not be recursive, but we can't know that has been checked beforehand
	private def HashSet<Event> stmOutputSetInContextRecursive(StateMachineBody stm, Controller context, HashSet<OperationSig> alreadyChecked, StateMachineBody outerstm) {
		var innerOutputs = ncOutputSet(stm)
		// unify the stmOutputs with the events of outerstm
		var outputs = new HashSet<Event>(innerOutputs.size())
		var outerEvents = getAllEvents(outerstm)
		for (innerevent : innerOutputs) {
			for (outerevent : outerEvents) {
				if (outerevent.name == innerevent.name
					&& ((innerevent.type === null && outerevent.type === null)
						|| typeCompatible(innerevent.type,outerevent.type))) {
					// outer state machine event is compatible, add it to the outputs
					outputs.add(outerevent)
				}
			}
		}
		// add outputs coming from required operations
		for (opDef : stmRequiredOpDefs(stm, context)) {
			if (!alreadyChecked.contains(opDef)) {
				alreadyChecked.add(opDef)
				outputs.addAll(stmOutputSetInContextRecursive(opDef, context, alreadyChecked, outerstm))
			}
			
		}
		outputs
	}
		
	def getAllEvents(StateMachineBody stm) {
		var events = new HashSet<Event>()
		events.addAll(stm.events)
		for (iface : stm.interfaces) {
			events.addAll(iface.events)
		}
		events
	}
	
	def HashSet<Event> stmOutputSetInContext(StateMachineBody stm, Controller context) {
		stmOutputSetInContextRecursive(stm, context, new HashSet<OperationSig>(), stm)
	}

	def HashSet<Event> ncOutputSet(NodeContainer nc) {
		var outputs = new HashSet<Event>()

		for (t : nc.transitions) {
			// need to check trigger and action of each transition, as both may contain a communication
			if (t.trigger !== null && t.trigger.get_type === CommunicationType.OUTPUT)
				outputs.add(t.trigger.event)
			if (t.trigger !== null && t.trigger.get_type === CommunicationType.SYNC)
				outputs.add(t.trigger.event) // c.x is an output
				// simple event in trigger is always an input
			if(t.action !== null) outputs.addAll(statementOutputSet(t.action))
		}

		for (n : nc.nodes) {
			// outputs from nested nodes must be added
			if(n instanceof NodeContainer) outputs.addAll(ncOutputSet(n))

			// actions in a state may also contain a communication
			if (n instanceof circus.robocalc.robochart.State) {
				for (a : n.actions) {
					if(a.action !== null) outputs.addAll(statementOutputSet(a.action))
				}
			}
		}

		outputs
	}

	def HashSet<Event> statementOutputSet(Statement s) {
		var outputs = new HashSet<Event>()

		if (s instanceof CommunicationStmt) {
			if (s.communication !== null && s.communication.get_type === CommunicationType.OUTPUT)
				outputs.add(s.communication.event)
			if (s.communication !== null && s.communication.get_type === CommunicationType.SYNC)
				outputs.add(s.communication.event) // c.x is an output
				// simple event in statement is always an output
			if (s.communication !== null && s.communication.get_type === CommunicationType.SIMPLE)
				outputs.add(s.communication.event)
		} else if (s instanceof SeqStatement) {
			for (s2 : s.statements) {
				outputs.addAll(statementOutputSet(s2))
			}
		} else if (s instanceof IfStmt) {
			outputs.addAll(statementOutputSet(s.getThen))
			outputs.addAll(statementOutputSet(s.getElse))
		}

		outputs
	}
	/*
	// recursively collects inputs of a node container, avoiding operations already checked
	// it is required by WFC O2 that operations not be recursive, but we can't know that has been checked beforehand
	private def HashSet<Event> stmInputSetInContextRecursive(StateMachineBody stm, Controller context, HashSet<OperationSig> alreadyChecked, StateMachineBody outerstm) {
		var innerInputs = ncInputSet(stm)
		// unify the innerInputs with the events of outerstm
		var inputs = new HashSet<Event>(innerInputs.size())
		var outerEvents = getAllEvents(outerstm)
		for (innerevent : innerInputs) {
			for (outerevent : outerEvents) {
				if (outerevent.name == innerevent.name
					&& ((innerevent.type === null && outerevent.type === null)
						|| typeCompatible(innerevent.type,outerevent.type))) {
					// outer state machine event is compatible, add it to the inputs
					inputs.add(outerevent)
				}
			}
		}
		// add inputs coming from required operations
		for (opDef : stmRequiredOpDefs(stm, context)) {
			if (!alreadyChecked.contains(opDef)) {
				alreadyChecked.add(opDef)
				inputs.addAll(stmInputSetInContextRecursive(opDef, context, alreadyChecked, outerstm))
			}
			
		}
		inputs
	}
	
	def HashSet<Event> stmInputSetInContext(StateMachineBody stm, Controller context) {
		stmInputSetInContextRecursive(stm, context, new HashSet<OperationSig>(), stm)
	}	*/

	def HashSet<Event> ncInputSet(NodeContainer nc) {
		var inputs = new HashSet<Event>()

		for (t : nc.transitions) {
			// need to check trigger and action of each transition, as both may contain a communication
			if (t.trigger !== null && t.trigger.get_type === CommunicationType.INPUT)
				inputs.add(t.trigger.event)
			// simple event in trigger is always an input
			if (t.trigger !== null && t.trigger.get_type === CommunicationType.SIMPLE)
				inputs.add(t.trigger.event)
			if(t.action !== null) inputs.addAll(statementInputSet(t.action))
		}

		for (n : nc.nodes) {
			// inputs from nested nodes must be added
			if(n instanceof NodeContainer) inputs.addAll(ncInputSet(n))

			// actions in a state may also contain a communication
			if (n instanceof circus.robocalc.robochart.State) {
				for (a : n.actions) {
					if(a.action !== null) inputs.addAll(statementInputSet(a.action))

				}
			}
		}

		inputs
	}

	def HashSet<Event> statementInputSet(Statement s) {
		var inputs = new HashSet<Event>()

		if (s instanceof CommunicationStmt) {
			if (s.communication !== null && s.communication.get_type === CommunicationType.INPUT)
				inputs.add(s.communication.event)
		} else if (s instanceof SeqStatement) {
			for (s2 : s.statements) {
				inputs.addAll(statementInputSet(s2))
			}
		} else if (s instanceof IfStmt) {
			inputs.addAll(statementInputSet(s.getThen))
			inputs.addAll(statementInputSet(s.getElse))
		}

		inputs
	}

	@Check
	def checkControllerConnections(ControllerDef ctrl) {
		var index = 0
		for (c : ctrl.connections) {
			if(c.isBidirec) return; // if the connection is bidirectional, then there are no restrictions
			/* Cn9 */
			if (c.from !== ctrl && c.from instanceof StateMachine) {
				if (ncInputSet(stmDef(c.from as StateMachine)).contains(c.efrom)) {
					error(
						c.efrom.name + " on " + c.from.name +
							" is used as the start of a unidirectional connection, but " + c.from.name +
							" receives input on " + c.efrom.name,
						c,
						RoboChartPackage.Literals.CONNECTION__FROM,
						index
					)
					
				} else {
						// event is used in an operation, determine which one
						for (op : stmRequiredOpDefs(stmDef(c.from as StateMachine), ctrl)) {
							var opInputs = ncInputSet(op)
							for (opEvent : opInputs) {
								// attempt to unify the operation event with the connection event
								if (c.efrom.name == opEvent.name
									&& ((opEvent.type === null && c.efrom.type === null)
										|| typeCompatible(opEvent.type,c.efrom.type))) {
									// the event does occur as an input in this operation, signal an error
									error(
										c.efrom.name + " on " + c.from.name +
											" is used as the start of a unidirectional connection, but " + c.from.name +
											" receives input on " + c.efrom.name +
											" via the operation " + op.name,
										c,
										RoboChartPackage.Literals.CONNECTION__FROM,
										index
									)
								}
							}
						}
					}

				}

			/* Cn8 */
			if (c.to !== ctrl && c.to instanceof StateMachine) {
				if (stmOutputSetInContext(stmDef(c.to as StateMachine), ctrl).contains(c.eto)) {
					// determine the source of the error more exactly
					if (ncOutputSet(stmDef(c.to as StateMachine)).contains(c.eto)) {
						error(
							c.eto.name + " on " + c.to.name + " is used as the end of a unidirectional connection, but " +
								c.to.name + " outputs on " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					} else {
						// event is used in an operation, determine which one (only check one level for simplicity of error reporting)
						for (op : stmRequiredOpDefs(stmDef(c.to as StateMachine), ctrl)) {
							var opOutputs = ncOutputSet(op)
							for (opEvent : opOutputs) {
								// attempt to unify the operation event with the connection event
								if (c.eto.name == opEvent.name
									&& ((opEvent.type === null && c.eto.type === null)
										|| typeCompatible(opEvent.type,c.eto.type))) {
									// the event does occur as an output in this operation, signal an error
									error(
										c.eto.name + " on " + c.to.name +
											" is used as the end of a unidirectional connection, but " + c.to.name +
											" outputs on " + c.eto.name +
											" via the operation " + op.name,
										c,
										RoboChartPackage.Literals.CONNECTION__TO,
										index
									)
								}
							}
						}
					}
				}
			}

			index++
			}
		}

	def Connection getControllerConnection(ControllerDef ctrl, Event e) {
		for (conn : ctrl.connections) {
			if((conn.from === ctrl && conn.efrom === e) || (conn.to === ctrl && conn.eto === e)) return conn
		}

		return null
	}
	
	/**
	 * Fallback for non-context controllers such as ANNs.
	 * 
	 * @param ctrl the controller
	 * @param e the event
	 * @return null
	 */
	def dispatch Connection getControllerConnection(GeneralController ctrl, Event e) {
		return null
	}

	@Check
	def checkModuleConnections(RCModule mod) {
		var index = 0

		for (c : mod.connections) {
			if (c.isBidirec) {
				/* Cn5 */
				// if the connection is bidirectional, controller connections to the events must be bidirectional
				if (c.to instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.to as Controller), c.eto)
					if (ctrlConn !== null && !ctrlConn.isBidirec) {
						error(
							c.eto.name + " on " + c.to.name +
								" is used as the end of a bidirectional connection, but " + c.to.name +
								" does not contain a bidirectional connection to " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					}
				}

				if (c.from instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.from as Controller), c.efrom)
					if (ctrlConn !== null && !ctrlConn.isBidirec) {
						error(
							c.efrom.name + " on " + c.efrom.name +
								" is used as the end of a bidirectional connection, but " + c.from.name +
								" does not contain a bidirectional connection to " + c.efrom.name,
							c,
							RoboChartPackage.Literals.CONNECTION__FROM,
							index
						)
					}
				}

			} else {
				/* Cn6 */
				// otherwise, the direction of the controller connections to the event must be consistent
				if (c.to instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.to as Controller), c.eto)
					if (ctrlConn !== null && ctrlConn.isBidirec) {
						error(
							c.eto.name + " on " + c.to.name +
								" is used as the end of a unidirectional connection, but " + c.to.name +
								" contains a bidirectional connection to " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					} else if (ctrlConn !== null && ctrlConn.from !== ctrlDef(c.to as Controller)) {
						error(
							c.eto.name + " on " + c.to.name +
								" is used as the end of a unidirectional connection, but " + c.to.name +
								" contains a connection to " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					}
				}
				
				/* Cn7 */
				if (c.from instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.from as Controller), c.efrom)
					if (ctrlConn !== null && ctrlConn.isBidirec) {
						error(
							c.efrom.name + " on " + c.from.name +
								" is used as the start of a unidirectional connection, but " + c.from.name +
								" contains a bidirectional connection to " + c.efrom.name,
							c,
							RoboChartPackage.Literals.CONNECTION__FROM,
							index
						)
					} else if (ctrlConn !== null && ctrlConn.to !== ctrlDef(c.from as Controller)) {
						error(
							c.efrom.name + " on " + c.from.name +
								" is used as the start of a unidirectional connection, but " + c.from.name +
								" contains a connection from " + c.efrom.name,
							c,
							RoboChartPackage.Literals.CONNECTION__FROM,
							index
						)
					}
				}
			}
			index++
		}
	}

	/* T2 */
	@Check
	def checkTriggersAreInputs(Transition t) {
		if (t.trigger !== null) {
			if (t.trigger.get_type === CommunicationType.OUTPUT || t.trigger.get_type === CommunicationType.SYNC) {
				error(
					"Only simple or input communications can be used as transition triggers",
					RoboChartPackage.Literals.TRANSITION__TRIGGER
				)
			}
		}
	}

	@Check
	def checkAsExp(AsExp e) {
		val etype = e.exp.typeFor
		val type = e.type
		if (!typeCompatible(type, etype)) {
			error(
				'Value of type ' + etype.printType + ' cannot be cast as ' + type.printType,
				RoboChartPackage.Literals.AS_EXP__TYPE,
				'CastTypeError'
			)
		}
	}
	
	/* TODO: Provide identifier for new WFC */
	@Check
	def timedConditionInUntimedSemantics(Transition t) {
		if (t.condition !== null && t.condition.isClockExp) {
			warning(
				'A transition condition in '+t.stateMachineBody.name+' uses timed expressions. In the untimed semantics, the whole condition is ignored.',
				RoboChartPackage.Literals.TRANSITION__CONDITION,
				'timedConditionInUntimedSemantics'
			)
		}
	}

	def dispatch Set<String> constantsRequired(StateMachineDef m) {
		var set = new HashSet<String>();
		for (i : m.RInterfaces) {
			for (l : i.variableList) {
				if (l.modifier == VariableModifier.CONST) {
					for (v : l.vars)
						set.add(v.name)
				}
			}
		}
		return set

	}
	
	def dispatch Set<String> constantsRequired(OperationDef m) {
		var set = new HashSet<String>();
		for (i : m.RInterfaces) {
			for (l : i.variableList) {
				if (l.modifier == VariableModifier.CONST) {
					for (v : l.vars)
						set.add(v.name)
				}
			}
		}
		return set

	}

	def dispatch Set<String> constantsRequired(ControllerDef m) {
		var set = new HashSet<String>();
		for (i : m.RInterfaces) {
			for (l : i.variableList) {
				if (l.modifier == VariableModifier.CONST) {
					for (v : l.vars)
						set.add(v.name)
				}
			}
		}
		return set
	}

	def rewriteType(Type t, Map<String, Type> map) {
		if (t instanceof TypeRef) {
			val ref = t.ref
			if (ref instanceof PrimitiveType && map.containsKey(ref.name)) {
				val repl = EcoreUtil2.copy(map.get(ref.name));
				return repl;
			} else {
				return t;
			}
		} else {
			val refs = t.eAllContents.filter[x|x instanceof TypeRef && (x as TypeRef).ref instanceof PrimitiveType].
				toList
			for (x : refs) {
				val ref = (x as TypeRef).ref
				if (ref instanceof PrimitiveType && map.containsKey(ref.name)) {
					val repl = EcoreUtil2.copy(map.get(ref.name));
					EcoreUtil2.replace(x, repl);
				}
			}
			return t;
		}
	}

	def rewriteType(Type t, Resource res) {
		val map = new HashMap<String, Type>()
		// TODO: check exactly what this line is supposed to do. Type instantiations no longer exist. Need to account for named types however
		//(res.contents.get(0) as RCPackage).typeInstantiations.forEach[x|map.put(x.left.name, x.right)]
		return rewriteType(t, map)
	}

	/* Helper */
	def Boolean isClockExp(Expression e) {
		if (e instanceof BooleanExp) {
			return false
		} else if (e instanceof IntegerExp) {
			return false
		} else if (e instanceof RefExp) {
			return false
		} else if (e instanceof SetExp) {
			return false
		} else if (e instanceof SeqExp) {
			return false
		} else if (e instanceof CallExp) {
			return false
		} else if (e instanceof GreaterThan) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof GreaterOrEqual) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof LessThan) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof LessOrEqual) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Equals) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Different) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof And) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Or) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Implies) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Iff) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Not) {
			return e.exp.isClockExp
		} else if (e instanceof Plus) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Minus) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Mult) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Div) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Modulus) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Neg) {
			return e.exp.isClockExp
		} else if (e instanceof Cat) {
			return false
		} else if (e instanceof ParExp) {
			return e.exp.isClockExp
		} else if (e instanceof ClockExp) {
			return true
		} else if (e instanceof TupleExp) {
			return false
		} else if (e instanceof ArrayExp) {
			return false
		} else if (e instanceof StateClockExp) {
			return true
		} else {
			return false
		}
	}
	
	def wfcE_NoInitVal(Expression e) {
		/* E1 */
		if (e instanceof SetComp) {
			if (e.variables.filter[v | v.initial !== null].size > 0) {
				error("E1: The variables declared in a set comprehension must not have initial values",
					RoboChartPackage.Literals.SET_COMP__VARIABLES,
					"SetCompNoInitVal"
				)
			}
		} else 
		/* E2 */
		if (e instanceof QuantifierExpression) {
			if (e.variables.filter[v | v.initial !== null].size > 0) {
				error("E2: Quantified variables in existential and universal quantifications must not have initial values",
					RoboChartPackage.Literals.QUANTIFIER_EXPRESSION__VARIABLES,
					"QuantExpNoInitVal"
				)
			}
		} else 
		/* E2 */
		if (e instanceof LambdaExp) {
			if (e.variables.filter[v | v.initial !== null].size > 0) {
				error("E3: The variables quantified in a lambda expression must not have initial values",
					RoboChartPackage.Literals.LAMBDA_EXP__VARIABLES,
					"LambdaExpNoInitVal"
				)
			}
		}
	}
	
	
	/**
	 * Identify containing StateMachineBody
	 * Termination requires absence of loops in containment hierarchy!
	 * @returns first StateMachineBody found in containment hierarchy or null if @par o is not transitively contained by a StateMachineBody
	 */
	def StateMachineBody identifyContainingStateMachineBody(EObject o) {
		if (o.eContainer instanceof StateMachineBody) {
			o.eContainer as StateMachineBody
		} else if (o.eContainer === null) {
			null
		} else {	
			identifyContainingStateMachineBody(o.eContainer)
		}
	}
	
	/* TS1 (is currently not allowed in RoboChart syntax) */
	@Check
	def wfcTS1_InvalidClockRef(ClockReset cr) {
		var stm = identifyContainingStateMachineBody(cr)
		if (stm instanceof StateMachineDef && !stm.clocks.contains(cr.clock) && !stm.interfaces.exists[i|i.clocks.contains(cr.clock)]) {
			error("TS1: A clock reset #C may only reference a clock declared within the action's containing state-machine," 
				+ "or in the case of a trigger, within the trigger's containing state-machine",
				RoboChartPackage.Literals.CLOCK_RESET__CLOCK,
				"InvalidClockRef"
			)
		} 
	}
	
	@Check
	def wfc_RecordFieldDefinition(FieldDefinition e) {
		val t2 = e.field.type
		val t1 = e.value.typeFor
		if (!typeCompatible(t1, t2)) {
			val msg = '''Field «e.field.name» of record «(e.eContainer as RecordExp).record.name» expects type «t2.printType», but «IF t1 === null»expression cannot be typed.«ELSE»expression has type «t1.printType»«ENDIF» '''
			error(
				msg,
				RoboChartPackage.Literals.FIELD_DEFINITION__VALUE,
				'FieldDefinitionTypeError'
			)
		}
	}
	
	@Check
	def wfc_MatrixType(MatrixType t) {
		val rowsIsIntExp = t.rows instanceof IntegerExp;
		val rowsIsConst = if (t.rows instanceof RefExp) {
			val ref = (t.rows as RefExp).ref 
			if (ref instanceof Variable && (ref as Variable).modifier == VariableModifier.CONST) {
				true
			} else false
		} else false
		val colsIsIntExp = t.columns instanceof IntegerExp;
		val colsIsConst = if (t.columns instanceof RefExp) {
			val ref = (t.rows as RefExp).ref 
			if (ref instanceof Variable && (ref as Variable).modifier == VariableModifier.CONST) {
				true
			} else false
		} else false
		if (!(rowsIsConst || rowsIsIntExp)) {
			error('''The values for rows in a matrix type must be either an integer or an integer valued constant.''',
				RoboChartPackage.Literals.MATRIX_TYPE__ROWS,
				'MatrixTypeRowsError'
			)
		}
		if (!(colsIsConst || colsIsIntExp)) {
			error('''The values for columns in a matrix type must be either an integer or an integer valued constant.''',
				RoboChartPackage.Literals.MATRIX_TYPE__COLUMNS,
				'MatrixTypeColumnsError'
			)
		}
	}
	
	@Check
	def wfc_VectorType(VectorType t) {
		val sizeIsIntExp = t.size instanceof IntegerExp;
		val sizeIsConst = if (t.size instanceof RefExp) {
			val ref = (t.size as RefExp).ref 
			if (ref instanceof Variable && (ref as Variable).modifier == VariableModifier.CONST) {
				true
			} else false
		} else false
		
		if (!(sizeIsConst || sizeIsIntExp)) {
			error('''The size of a vector type must be either an integer or an integer valued constant.''',
				RoboChartPackage.Literals.VECTOR_TYPE__SIZE,
				'VectorTypeSizeError'
			)
		}
	}

	@Check
	def junctionWFC_PJ3(ProbabilisticJunction j) {
		val parent = j.eContainer as NodeContainer
		val lstExpr = new ArrayList<Expression>()

		for (t : parent.transitions.filter[t|t.source === j]) {
			lstExpr.add(t.probability)
		}

		if(!sumExprEq1(lstExpr)) {
			warning(
				'Sum of probabilities of outgoing transitions from a ProbabilisticJunction in ' + parent.name + ' might not be equal to 1',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'probsfromProbJuncNotEqual1'
			)
		}
	}

	def private Boolean sumExprEq1(List<Expression> exprs) {
		val num = exprs.filter[t|(t instanceof IntegerExp) || 
			(t instanceof FloatExp)
		].size
		if(exprs.size === num) {
			var sum = 0.0
			for(e: exprs) {
				if(e instanceof IntegerExp) {
					sum = sum + (e as IntegerExp).value
				} else if(e instanceof FloatExp) {
					sum = sum + (e as FloatExp).value
				}
			}

			if(sum === 1.0) {
				return true;
			} else {
				return false;
			}
		}

		return false
	}
	
	// return 0 - OK, 1 - violate, 2 - might violate 
	def private Integer probExprBetween0_1(Expression e) {
		if(e instanceof IntegerExp) {
			if((e as IntegerExp).value > 1 || (e as IntegerExp).value < 0) {
				return 1;
			}
		} else if(e instanceof FloatExp) {
			if((e as FloatExp).value > 1.0 || 
				(e as FloatExp).value < 0.0) {
				return 1;
			}
		} else {
			return 2;
		}

		return 0;
	}
	
	
	/******************************************************************
	 **
	 ** ANNs
	 **
	 ** These correspond more or less directly to the Z specifications
	 ** given as part of Ziggy's metamodel.
	 **
	 *****************************************************************/
	
	// weights are a tensor:
	// - layers of
	//   - neurons containing
	//     - weights for each neuron in the preceding layer
	
	//
	// Typing
	//
	
	@Check
	def checkANNParameterTyping(ANNParameters params) {
		checkANNWeightsTyping(params)
		checkANNBiasesTyping(params)
		checkANNLayerStructureTyping(params)
	}
	
	private def checkANNWeightsTyping(ANNParameters params) {
		// TODO: tidy this up
		params.weights.values.forEach[layer, i|
			switch layer {
				SeqExp : layer.values.forEach[neuron, j|
					switch neuron {
						SeqExp : neuron.values.forEach[input, k|
							if (! ( (input instanceof FloatExp) || 
								(input instanceof Neg && (input as Neg).exp instanceof FloatExp)
							) ) {
								error('''Weight for input «k+1» on neuron «j+1» at layer «i+1» should be a float''',
									RoboChartPackage.Literals.ANN_PARAMETERS__WEIGHTS,
									"ANNTypingWeightsInput"							
								)
							}
						]
						default : error('''Weights on neuron «j+1» at layer «i+1» should be a vector''',
							RoboChartPackage.Literals.ANN_PARAMETERS__WEIGHTS,
							"ANNTypingWeightsNeuron"							
						)
					}
				]
				default : error('''Weights at layer «i+1» should be a matrix''',
					RoboChartPackage.Literals.ANN_PARAMETERS__WEIGHTS,
					"ANNTypingWeightsLayer"
				)
			}
		]
	}
	
	private def checkANNBiasesTyping(ANNParameters params) {
		// TODO: tidy this up
		params.biases.values.forEach[layer, i|
			switch layer {
				SeqExp : layer.values.forEach[neuron, j|
					if (! ( (neuron instanceof FloatExp) || 
								(neuron instanceof Neg && (neuron as Neg).exp instanceof FloatExp)
							) ) {
						error('''Bias for neuron «j+1» at layer «i+1» should be a float''',
							RoboChartPackage.Literals.ANN_PARAMETERS__BIASES,
							"ANNTypingBiasesNeuron"							
						)
					}
				]
				default : error('''Biases at layer «i+1» should be a vector''',
					RoboChartPackage.Literals.ANN_PARAMETERS__BIASES,
					"ANNTypingBiasesLayer"
				)
			}
		]
	}
	
	private def checkANNLayerStructureTyping(ANNParameters params) {
		// TODO: tidy this up
		params.layerstructure.values.forEach[layer, i|
			if (!(layer instanceof IntegerExp)) {
				 error('''Layer size at layer «i+1» should be an integer''',
					RoboChartPackage.Literals.ANN_PARAMETERS__LAYERSTRUCTURE,
					"ANNTypingLayerStructureLayer"
				)
			}
		]
	}
	
	//
	// ANN1
	//
	
	/**
	 * Checks ANN well-formedness condition 1.
	 * 
	 * <p>
	 * The inputContext and outputContext each define at least one event, and layerstructure,
	 * weights, and biases are non-empty and of the same size, if not null.
	 * </p>
	 * 
	 * @param params the ANN parameters structure to check
	 */
	@Check
	def checkANN1(ANNParameters params) {
		checkANN1InOutPositive(params)
		checkANN1StructureSizes(params)
	}
	
	/**
	 * Checks that the inputContext and outputContext each define at least one event.
	 * 
	 * @param params the ANN parameters structure to check
	 */
	private def checkANN1InOutPositive(ANNParameters params) {
		#[INSIZE, OUTSIZE].forEach[
			val c = getIn(params)
			var ev = allEvents(c)
			if (ev.size <= 0) {
				error('''«name» size is «ev.size», but must be positive''',
					ref,
					'''ANN1«name»SizeNonPositive'''
				)
			}
		]
	}
	
	/**
	 * Checks that layer structure, weights, and biases are non-empty and of
	 * the same size, if not null.
	 *
	 * @param params the ANN parameters structure to check
	 */
	def private checkANN1StructureSizes(ANNParameters params) {
		/* If some, but not all, of the structures are present,
		 * this is a violation of ANN3 and we needn't check ANN1.
		 */
		val allPresent = ALL_STRUCTURES.forall[!isNullIn(params)]
		if (allPresent) {
			checkANN1StructuresNotEmpty(params)
			checkANN1StructuresCompatibleWithLayers(params)
		}	
	}

	/**
	 * Checks that layer structure, weights, and biases are non-empty and of
	 * the same size, if not null.
	 *
	 * @param params the ANN parameters structure to check
	 */
	private def checkANN1StructuresNotEmpty(ANNParameters params) {
		// Already checked that all structures are present, no need to null-check
		ALL_STRUCTURES.forEach[
			val structure = getIn(params)
			if (structure !== null && structure.empty) {
				error('''«name» cannot be empty''',	ref, '''ANN1«name»Empty''')
			}
		]
	}
	
	private def checkANN1StructuresCompatibleWithLayers(ANNParameters params) {
		// Already checked that all structures are present, no need to null-check
		val layers = params.layerstructure
		val numLayers = layers.values.size
		
		// No need to check the layer structure against itself
		#[WEIGHTS, BIASES].forEach[
			checkSeqSize(getIn(params), numLayers, name, ref, '''ANN1«name»SizeMismatch''')
		]
	}


	//
	// ANN2
	//
	
	/**
	 * Checks ANN well-formedness condition 2.
	 *
	 * <p>
	 *  If filename is null, then weights, biases, and layerstructure are not.
	 * </p>
	 * 
	 * @param params the ANN parameters structure to check
	 */
	@Check
	def checkANN2(ANNParameters params) {
		if (params.hasFile) {
			return
		}

		ALL_STRUCTURES.forEach[
			if (isNullIn(params)) {
				error('''«name» must be given if a filename is not given''', ref, '''ANN2NoFilenameNo«name»''')
			}
		]
	}

	
	//
	// ANN3
	//
	
	/**
	 * Checks ANN well-formedness condition 3.
	 *
	 * <p>
	 * Either layerstructure, weights, and biases are all null, in which case
	 * filename is not, or they are all different from null.
	 * </p>
	 * 
	 * @param params the ANN parameters structure to check
	 */
	@Check
	def checkANN3(ANNParameters params) {
		// TODO: check to make sure this is the right reading of the Z
		val allAbsent = ALL_STRUCTURES.forall[isNullIn(params)]
		if (allAbsent) {
			checkANN3FilenameExists(params)
		} else {
			checkANN3StructuresPresent(params)
		}
	}
	
	private def checkANN3FilenameExists(ANNParameters params) {
		if (params.noFile) {
			error("If parameters are not given, a filename must be given",
				RoboChartPackage.Literals.ANN_PARAMETERS__FILENAME,
				"ANN3NoParamsFilenameMustExist"
			)
		}
	}

	private def checkANN3StructuresPresent(ANNParameters params) {
		ALL_STRUCTURES.forEach[
			if (isNullIn(params)) {
				error('''«name» not given, but at least one other structure was''',
					ref,
					'''ANN3«name»MissingOthersPresent'''
				)
			}
		]
	}
	
	
	//
	// ANN4
	//
	
		
	/**
	 * Checks ANN well-formedness condition 4.
	 *
	 * <p>
	 * The activationfunction is not specified if, and only if, filename is not null.
	 * </p>
	 * 
	 * @param params the ANN parameters structure to check
	 */
	@Check
	def checkANN4(ANNParameters params) {
		// no activation function <=> has filename
		if (params.hasActivationFunction && params.hasFile) {
			error("Must not have an activation function if a filename is present",
				RoboChartPackage.Literals.ANN_PARAMETERS__ACTIVATIONFUNCTION,
				"ANN4ActivationFunctionAndFilename"
			)
		} else if (params.noActivationFunction && params.noFile) {
			error("Must have a filename if no activation function is present",
				RoboChartPackage.Literals.ANN_PARAMETERS__FILENAME,
				"ANN4NoActivationFunctionNoFilename"
			)			
		}
	}
	
	
	//
	// ANN5
	//
	
	/**
	 * Checks ANN well-formedness condition 5.
	 *
	 * <p>
	 * For every i, the size of weights[i] and biases[i] is layerstructure[i].
	 * </p>
	 *
	 * @param params the ANN parameters structure to check
	 */
	@Check
	def checkANN5(ANNParameters params) {
		if (params.hasFile) {
			return
		}
	
		params.forEachLayer[lsize, i|
			#[WEIGHTS, BIASES].forEach[
				val layers = getIn(params)
				if (layers === null || layers.size() <= i) {
					// Ill-formed or nonexistent
					return
				}
				
				layers.get(i).ifSeq[seq|
					checkSeqSize(seq, lsize, '''«name» at layer «i+1»''', ref, '''ANN5«name»BadSize''')
				]
			]
		]
	}


	//
	// ANN6
	//
	
	/**
	 * Checks ANN well-formedness condition 6.
	 * 
	 * <p>
	 * For every i, and for all j, the size of weights[i][j] is
	 * layerstructure[i-1] when i is greater than 1, or insize otherwise.
	 * </p>
	 * 
	 * @param params the ANN parameters structure to check
	 */
	@Check
	def checkANN6(ANNParameters params) {
		if (params.hasFile) {
			return
		}
		
		val weights = params.weights.values
	
		params.forEachLayer[lsize, i|
			// In case the sizes are ill-formed:
			if (weights.size() <= i) {
				return
			}

			val want = expectedLayerWeightsSize(params, i)
						
			val neurons = weights.get(i)
			neurons.forEachIfMatrix[neuron, j|
				checkSeqSize(neuron,
					want,
					'''Weights at neuron «j+1» of layer «i+1»''',
					RoboChartPackage.Literals.ANN_PARAMETERS__WEIGHTS,
					"ANN6NeuronWeightsBadSize"
				)
			]
		]
	}
	
	private def Integer expectedLayerWeightsSize(ANNParameters params, int layer) {
		if (layer < 0) {
			// This shouldn't happen in practice.
			return null
		}
		
		if (layer == 0) {
			// First layer should have weights corresponding to inputs
			return insize(params)
		}

		val layers = params.layerstructure.values
		if (layers.size() <= layer) {
			// Sizes ill-formed
			return null
		}
		
		params.layerstructure.values.get(layer-1).assertInt
	}


	//
	// WF7
	//
	
	/**
	 * Checks ANN well-formedness condition 7.
	 * 
	 * <p>
	 * The connections to and from an ANN controller match the nature of the
	 * events (inputs and outputs) in their directions and types.
	 * </p>
	 * 
	 * @param mod the RoboChart module to check
	 */
	@Check
	def checkANN7(ANNController ctrl) {
		/* The Z specification of ANN8 starts with an outer quantification
		 * over RCModule.  We could do the same here, but then we wouldn't
		 * be able to tag the specific parts of the controller that are
		 * ill-formed; we would only be able to tag the 'nodes' part of the
		 * controller.
		 * 
		 * Instead, we assume that quantifying over controllers and following
		 * the containment references backwards into the parent module will
		 * work.
		 */
		val mod = EcoreUtil2.getContainerOfType(ctrl, RCModule)
		if (mod === null) {
			return
		}
		
		val inputs = mod.connections.filter[to == ctrl].toSet
		val outputs = mod.connections.filter[from == ctrl].toSet
			
		checkANN7SizesCompatible(ctrl, inputs, outputs)
		//Don't believe we need this. 
		//checkANN8EventsExist(ctrl, inputs, outputs)
	}
	
	private def checkANN7SizesCompatible(ANNController ctrl, Set<Connection> inputs, Set<Connection> outputs) {
		checkANN7SizeCompatible(ctrl, inputs, INSIZE)
		checkANN7SizeCompatible(ctrl, outputs, OUTSIZE)
	}
	
	private def checkANN7SizeCompatible(ANNController ctrl, Set<Connection> conns, ANNParameter<Context> sizeParam) {
		val params = ctrl.annparameters
		if (params === null) {
			// ill-formed, but we won't report that here
			return
		}

		checkSeqSize(conns,
			allEvents(sizeParam.getIn(params)).size,
			'''«sizeParam.name» connection set''',
			RoboChartPackage.Literals.ANN__ANNPARAMETERS,
			'''ANN7«sizeParam.name»SizeIncompatible'''
		)
	}
	
	/*
	 * ANN8:
	 * ANN Controller cannot define variables, clocks, or events. 
	 */
	@Check
	def checkANN8(ANNController ctrl) {
		if (ctrl.clocks.size > 0 ||  ctrl.variableList.size > 0 || ctrl.operations.size > 0 || ctrl.events.size > 0) {
			error(
				getName(ctrl) + ' cannot define this parameter.',
				RoboChartPackage.Literals.ANN__ANNPARAMETERS,
				"ANN8"
			)
		}
		
	}
	/*
	 * ANN9:
	 *
	 * ANN Controllers cannot define, provide, or require interfaces. 
	  */
	@Check
	def checkANN9(ANNController ctrl) {
		for (i : ctrl.PInterfaces) {
			error(
				ctrl.name + ' is an anncontroller and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'ANN9'
			)
		}
		
		for (i : ctrl.RInterfaces) {
			error(
				ctrl.name + ' is an anncontroller and cannot require interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__RINTERFACES,
				'ANN9'
			)
		}
		
		for (i : ctrl.interfaces) {
			error(
				ctrl.name + ' is an anncontroller and cannot define interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__RINTERFACES,
				'ANN9'
			)
		}
	}
	
	/*
	 * ANN10:
	 * An ANNController's input and output contexts cannot provide or require interfaces.
	 */
	@Check
	def checkANN10(ANNController ctrl) {
		val inputContext = ctrl.annparameters.inputContext
		if (inputContext.PInterfaces.size > 0 || inputContext.RInterfaces.size > 0) 
			error(
					ctrl.name + ' is an anncontroller and its input context cannot provide or require interfaces',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ANN10'
				)
		val outputContext = ctrl.annparameters.outputContext
		if (outputContext.PInterfaces.size > 0 || outputContext.RInterfaces.size > 0) 
			error(
					ctrl.name + ' is an anncontroller and its output context cannot provide or require interfaces',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ANN10'
				)
	}
	
	/*
	 * ANN11:
	 * An ANNController's input and output contexts cannot define variables or clocks.
	 */
	@Check
	def checkANN11(ANNController ctrl) {
		for (i : ctrl.annparameters.inputContext.interfaces) {
			if (i.clocks.size > 0 ||  i.variableList.size > 0 || i.operations.size > 0)
				error(
					ctrl.name + ' is an anncontroller and its input context can only define events',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ANN11'
				)
		}
		
		for (i : ctrl.annparameters.outputContext.interfaces) {
			if (i.clocks.size > 0 ||  i.variableList.size > 0 || i.operations.size > 0)
				error(
					ctrl.name + ' is an anncontroller and its output context can only define events',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ANN11'
				)
		}
	}

	
	//
	// WF12
	//
	
	/**
	 * Checks ANN well-formedness condition 12.
	 * 
	 * <p>
	 * The connections to an ANNController must be to events in its input context, and connections from an ANNController must be from its output context. 
	 * </p>
	 * 
	 * @param mod the RoboChart module to check
	 */
	@Check
	def checkANN12(ANNController ctrl) {
		
		val mod = EcoreUtil2.getContainerOfType(ctrl, RCModule)
		if (mod === null) {
			return
		}
		val inputs = mod.connections.filter[to == ctrl].toSet.iterator()
		val outputs = mod.connections.filter[from == ctrl].toSet.iterator()
		val inevents = 
		{ 
			var inevents = new HashSet<Event>()
			while(inputs.hasNext()) {
				inevents.add(inputs.next().eto)
			}
			inevents
		}
		val outevents = 
		{ 
			var outevents = new HashSet<Event>()
			while(outputs.hasNext()) {
				outevents.add(outputs.next().efrom)
			}
			outevents
		}
		
		val inputContext = ctrl.annparameters.inputContext
		val outputContext = ctrl.annparameters.outputContext
		
		val inputContextEvents = allEvents(inputContext)
		val outputContextEvents = allEvents(outputContext)
		
		//Every inevent must be contained in allEvents(
		for(e : inevents) {
			if(!inputContextEvents.contains(e)) {
				error("All incoming connections must connect to events in the input context",
					RoboChartPackage.Literals.ANN__ANNPARAMETERS,
					"ANN12ConnectionsContext"
				)
			}
		}
		
		for(e : outevents) {
			if(!outputContextEvents.contains(e)) {
				error("All outgoing connections must connect to events in the output context",
					RoboChartPackage.Literals.ANN__ANNPARAMETERS,
					"ANN12ConnectionsContext"
				)
			}
		}
	}

	
	/*
	 * Special WF condition: we throw an error if there is an ANNOperation, we will add support for this later.  
	  */
	 @Check
	 def noANNOperation(ANNOperation op) {
	 	error('''ANN operations are not supported in this version.''',
				RoboChartPackage.Literals.ANN_OPERATION__RINTERFACES,
				"ANN9VariableCount"
			)
	 }

	//
	// Helper code for handling ANN parameters
	//
	
	/**
	 * Bundles together the basic information used to perform a WFC
	 * check on one of the expressions in an ANNParameters bundle.
	 * 
	 * @param <T> the type of the parameter
	 */
	@Data private static class ANNParameter<T> {
		String name
		EReference ref
		Function<ANNParameters, T> getter
		
		/**
		 * Accesses this parameter in a parameters structure.
		 * 
		 * @param params the parameters structure
		 *
		 * @return the requisite parameter
		 */
		def T getIn(ANNParameters params) {
			getter.apply(params)
		}
		
		/**
		 * Checks whether a parameter is null in a parameters structure.
		 * 
		 * @param params the parameters structure
		 * 
		 * @return true if and only if the parameter is null
		 */
		def boolean isNullIn(ANNParameters params) {
			getIn(params) === null
		}
	}

	static val INSIZE = new ANNParameter("Input", RoboChartPackage.Literals.ANN_PARAMETERS__INPUT_CONTEXT, [inputContext])
	static val OUTSIZE = new ANNParameter("Output", RoboChartPackage.Literals.ANN_PARAMETERS__OUTPUT_CONTEXT, [outputContext])

	static val WEIGHTS = new ANNParameter("Weights", RoboChartPackage.Literals.ANN_PARAMETERS__WEIGHTS, [weights?.values])
	static val BIASES = new ANNParameter("Biases", RoboChartPackage.Literals.ANN_PARAMETERS__BIASES, [biases?.values])
	static val LAYERS = new ANNParameter("Layers", RoboChartPackage.Literals.ANN_PARAMETERS__LAYERSTRUCTURE, [layerstructure?.values])

	/**
	 * Lists all of the n-dimensional structures that occur within the
	 * ANN parameters.
	 */
	static val ALL_STRUCTURES = #[WEIGHTS, BIASES, LAYERS]
	
	//Get all events from an Input or Output Context
	private def allEvents(Context c) {
		var events = new HashSet<Event>()
		events.addAll(c.events)
		for (iface : c.interfaces) {
			events.addAll(iface.events)
		}
		events
	}
	
	//Gets the input size, as an integer, from an ANNController.
	private def insize(ANNParameters p) {
		return allEvents(p.inputContext).size
	}
	
	//Gets the input size, as an integer, from an ANNController.
	private def outsize(ANNParameters p) {
		return allEvents(p.outputContext).size
	}

	
	private def checkSeqSize(Collection<?> coll, int want, CharSequence name, EReference ref, CharSequence code) {
		if (coll === null) {
			// Assume that, if this is ill-formed, it is handled elsewhere
			return
		}
		
		val got = coll.size
		if (got != want) {
			error('''«name» must be of size «want», but was «got»''', ref, code.toString())
		}				
	}
	
	private def static Integer asInt(IntegerExp e) {
		// Don't use ?., it'll produce an int not an Integer
		if (e === null) {
			null
		} else {
			e.value
		}
	}
	
	/**
	 * Asserts that the given expression is a matrix or tensor; if it is,
	 * applies the given action to each element of its outermost dimension.
	 * 
	 * @param e      the expression in question
	 * @param action an action to apply to each expression list
	 */
	def private forEachIfMatrix(Expression e, BiConsumer<List<Expression>, Integer> action) {
		e.forEachIfSeq[v, i| v.ifSeq[action.accept(it, i)]]
	}
	
	/**
	 * Asserts that the given expression is a sequence; if it is,
	 * applies the given action to each element.
	 * 
	 * @param e      the expression in question
	 * @param action an action to apply to each expression
	 */
	def private forEachIfSeq(Expression e, BiConsumer<Expression, Integer> action) {
		e.ifSeq[forEach(action)]
	}
	
	/**
	 * Asserts that the given expression is a sequence; if it is,
	 * applies the given action to its contents list.
	 * 
	 * @param e      the expression in question
	 * @param action an action to apply to the expression
	 */
	def private ifSeq(Expression e, Consumer<List<Expression>> action) {
		switch e {
			SeqExp : action.accept(e.values)
			default : {}
		}	
	}
	
	def Iterable<Integer> assertVector(SeqExp expr) {
		expr.values.map[assertInt]
	}
	
	/**
	 * Asserts that an expression is an integer.
	 * 
	 * @param expr the expression
	 * 
	 * @return the integer value of expr, or null if it is not an integer expression
	 */
	def private Integer assertInt(Expression expr) {
		switch expr {
			IntegerExp : expr.value
			default : null
		}
	}

	//
	// Input/output size checks
	//
		
	def private boolean equalsSizeSum(int numEvents, ANNController ctrl) {
		val params = ctrl.annparameters
		// params being null isn't well-formed, but we don't check that here
		params !== null && (numEvents == insize(params) + outsize(params))
	}
	
	def private boolean equalsInsize(int numParams, ANNOperation op) {
		val params = op.annparameters
		// params being null isn't well-formed, but we don't check that here
		params !== null && numParams == insize(params)
	}

	def private boolean equalsOutsize(int numParams, ANNOperation op) {
		val params = op.annparameters
		// params being null isn't well-formed, but we don't check that here
		params !== null && numParams == outsize(params)
	}

	//
	// Extension methods for ANNParameters
	//
	
	/**
	 * Checks whether the ANN is taking its parameters from a file.
	 * 
	 * @param params the ANN parameters
	 * 
	 * @return true if and only if the filename is non-null
	 */ 
	private def boolean hasFile(ANNParameters params) {
		params.filename !== null
	}	

	/**
	 * Checks whether the ANN is not taking its parameters from a file.
	 * 
	 * @param params the ANN parameters
	 * 
	 * @return true if and only if the filename is null
	 */ 
	private def boolean noFile(ANNParameters params) {
		params.filename === null
	}
	
	/**
	 * Checks whether the ANN has an activation function.
	 * 
	 * @param params the ANN parameters
	 * 
	 * @return true if and only if the activation function is defined
	 */
	private def boolean hasActivationFunction(ANNParameters params) {
		params.activationfunction !== ActivationFunction.NOTSPECIFIED;
	}

	/**
	 * Checks whether the ANN does not have an activation function.
	 * 
	 * @param params the ANN parameters
	 * 
	 * @return true if and only if the activation function is undefined
	 */	
	private def boolean noActivationFunction(ANNParameters params) {
		params.activationfunction === ActivationFunction.NOTSPECIFIED;
	}
	
	private def forEachLayer(ANNParameters params, BiConsumer<Integer, Integer> consumer) {
		params.layerstructure.assertVector?.forEach(consumer)
	}
}
