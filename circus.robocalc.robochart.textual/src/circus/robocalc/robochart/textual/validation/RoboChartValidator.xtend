/********************************************************************************
 * Copyright (c) 2019 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Alvaro Miyazawa - initial definition
 ********************************************************************************/

/*
 * generated by Xtext 2.17.1
 */
package circus.robocalc.robochart.textual.validation

import circus.robocalc.robochart.And
import circus.robocalc.robochart.ArrayExp
import circus.robocalc.robochart.AsExp
import circus.robocalc.robochart.Assignment
import circus.robocalc.robochart.BooleanExp
import circus.robocalc.robochart.Call
import circus.robocalc.robochart.CallExp
import circus.robocalc.robochart.Cat
import circus.robocalc.robochart.ClockExp
import circus.robocalc.robochart.ClockReset
import circus.robocalc.robochart.Connection
import circus.robocalc.robochart.ConnectionNode
import circus.robocalc.robochart.Context
import circus.robocalc.robochart.Controller
import circus.robocalc.robochart.ControllerDef
import circus.robocalc.robochart.ControllerRef
import circus.robocalc.robochart.Different
import circus.robocalc.robochart.Div
import circus.robocalc.robochart.DuringAction
import circus.robocalc.robochart.EntryAction
import circus.robocalc.robochart.Enumeration
import circus.robocalc.robochart.Equals
import circus.robocalc.robochart.Event
import circus.robocalc.robochart.ExitAction
import circus.robocalc.robochart.Expression
import circus.robocalc.robochart.Final
import circus.robocalc.robochart.FunctionType
import circus.robocalc.robochart.GreaterOrEqual
import circus.robocalc.robochart.GreaterThan
import circus.robocalc.robochart.IfStmt
import circus.robocalc.robochart.Iff
import circus.robocalc.robochart.Implies
import circus.robocalc.robochart.Initial
import circus.robocalc.robochart.IntegerExp
import circus.robocalc.robochart.Interface
import circus.robocalc.robochart.Junction
import circus.robocalc.robochart.LambdaExp
import circus.robocalc.robochart.LessOrEqual
import circus.robocalc.robochart.LessThan
import circus.robocalc.robochart.Literal
import circus.robocalc.robochart.Minus
import circus.robocalc.robochart.Modulus
import circus.robocalc.robochart.Mult
import circus.robocalc.robochart.NamedElement
import circus.robocalc.robochart.Neg
import circus.robocalc.robochart.NodeContainer
import circus.robocalc.robochart.Not
import circus.robocalc.robochart.Operation
import circus.robocalc.robochart.OperationDef
import circus.robocalc.robochart.OperationRef
import circus.robocalc.robochart.OperationSig
import circus.robocalc.robochart.Or
import circus.robocalc.robochart.ParExp
import circus.robocalc.robochart.Parameter
import circus.robocalc.robochart.Plus
import circus.robocalc.robochart.PrimitiveType
import circus.robocalc.robochart.ProductType
import circus.robocalc.robochart.QuantifierExpression
import circus.robocalc.robochart.RCModule
import circus.robocalc.robochart.RecordType
import circus.robocalc.robochart.RefExp
import circus.robocalc.robochart.RoboChartFactory
import circus.robocalc.robochart.RoboChartPackage
import circus.robocalc.robochart.RoboticPlatform
import circus.robocalc.robochart.RoboticPlatformDef
import circus.robocalc.robochart.RoboticPlatformRef
import circus.robocalc.robochart.SendEvent
import circus.robocalc.robochart.SeqExp
import circus.robocalc.robochart.SeqStatement
import circus.robocalc.robochart.SetComp
import circus.robocalc.robochart.SetExp
import circus.robocalc.robochart.StateClockExp
import circus.robocalc.robochart.StateMachine
import circus.robocalc.robochart.StateMachineBody
import circus.robocalc.robochart.StateMachineDef
import circus.robocalc.robochart.StateMachineRef
import circus.robocalc.robochart.Statement
import circus.robocalc.robochart.Transition
import circus.robocalc.robochart.Trigger
import circus.robocalc.robochart.TriggerType
import circus.robocalc.robochart.TupleExp
import circus.robocalc.robochart.Type
import circus.robocalc.robochart.TypeRef
import circus.robocalc.robochart.VarRef
import circus.robocalc.robochart.Variable
import circus.robocalc.robochart.VariableModifier
import circus.robocalc.robochart.Wait
import circus.robocalc.robochart.textual.RoboCalcTypeProvider
import com.google.inject.Inject
import java.util.HashMap
import java.util.HashSet
import java.util.LinkedList
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.serializer.ISerializer
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import circus.robocalc.robochart.ProbabilisticJunction
import java.util.ArrayList
import circus.robocalc.robochart.FloatExp

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RoboChartValidator extends AbstractRoboChartValidator {
	
	@Inject protected extension RoboCalcTypeProvider
	@Inject protected IQualifiedNameProvider qnp
	@Inject protected IResourceDescriptions rds;
	
	@Inject ISerializer s;

	@Inject protected extension PrintingServices
	
	def print(EObject o) {
		return s.serialize(o)
	}

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					RoboChartPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	public static val NO_INITIAL = 'noInitialJunction'
	public static val COMPOSITE_STATE_WITHOUT_STATE = 'compositeStateWithoutState'
	public static val ASSIGNEMENT_TO_PARAMETER = 'assignmentToParameter'

	/* S2 */
	@Check
	def stateWFC(circus.robocalc.robochart.State s) {
		if (s.actions.filter[a|a instanceof EntryAction].size > 1) {
			error(
				'State ' + s.name + ' should have at most one entry action',
				RoboChartPackage.Literals.STATE__ACTIONS,
				'stateWithMultipleEntryActions'
			)
		}
		if (s.actions.filter[a|a instanceof DuringAction].size > 1) {
			error(
				'State ' + s.name + ' should have at most one during action',
				RoboChartPackage.Literals.STATE__ACTIONS,
				'stateWithMultipleDuringActions'
			)
		}
		if (s.actions.filter[a|a instanceof ExitAction].size > 1) {
			error(
				'State ' + s.name + ' should have at most one entry action',
				RoboChartPackage.Literals.STATE__ACTIONS,
				'stateWithMultipleExitActions'
			)
		}

	}

	@Check
	def initialWFC(Initial i) {
		val parent = i.eContainer as NodeContainer
		/* IJ1 */
		if (parent.transitions.filter[t|t.target === i].size > 0) {
			error(
				'A transition cannot target the initial junction in ' + parent.name,
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noTransitionToInitial'
			)
		}
		/* IJ2 */
		if (parent.transitions.filter[t|t.source === i].size === 0) {
			error(
				'An initial junction in ' + parent.name + ' should have at least one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionFromJunction'
			)
		}
		if (parent.transitions.filter[t|t.source === i].size > 1) {
			error(
				'An initial junction in ' + parent.name + ' should not have more than one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionFromJunction'
			)
		}
	}

	@Check
	def finalWFC(Final f) {
		val parent = f.eContainer as NodeContainer
		/* FS1 */
		if (parent.transitions.filter[t|t.source === f].size > 0) {
			error(
				'A transition cannot start in the final state in ' + parent.name,
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'noTransitionFromFinal'
			)
		}
		/* @TODO: (FS2/S3) currently missing in RefMan, should FS2 be 
		 * generalised to all states?
		 */
		if (parent.transitions.filter[t|t.target === f].size === 0) {
			error(
				'The final state in ' + parent.name + ' should have at least one incoming transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionToJunction'
			)
		}
	}

	@Check
	def transitionWFC(Transition t) {
		/* J3 */
		if (t.trigger !== null && t.trigger.event !== null) {
			if (!(t.source instanceof circus.robocalc.robochart.State)) {
				error(
					'A transition containing a trigger must start on a state',
					RoboChartPackage.Literals.TRANSITION__TRIGGER,
					'transitionWithTriggerFromNonState'
				)
			}
		}
		/* T1 */
		val srcParent = t.source.eContainer
		val tgtParent = t.target.eContainer
		if (srcParent !== tgtParent) {
			error(
				'The source and target of a transition should belong to the same container',
				RoboChartPackage.Literals.TRANSITION__SOURCE,
				'noInterlevelTransition'
			)
		}
	}

	
	/* J1 */
	@Check
	def junctionWFC1(Junction j) {
		if(j instanceof Initial) return
		val parent = j.eContainer as NodeContainer
		if (parent.transitions.filter[t|t.source === j].size === 0) {
			error(
				'A junction in ' + parent.name + ' should have at least one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionFromJunction'
			)
		}
	}

	@Check
	def junctionWFC2(Junction j) {
		if(j instanceof Initial) return
		val parent = j.eContainer as NodeContainer
		if (parent.transitions.filter[t|t.target === j].size === 0) {
			error(
				'A junction in ' + parent.name + ' should have at least one incoming transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'transitionToJunction'
			)
		}
	}

	@Check
	def checkAssignmentToParameter(VarRef a) {
		if (a.name instanceof Parameter)
			error(
				'It is not possible to assign to a parameter',
				RoboChartPackage.Literals.VAR_REF__NAME,
				ASSIGNEMENT_TO_PARAMETER
			)
	}

	/* STM3 and (because OperationDef is a NodeContainer) O1:STM3 */
	@Check
	def checkStateMachineHasInitialState(NodeContainer stm) {
		if (stm.nodes.size > 0 && stm.nodes.filter(Initial).size !== 1)
			warning(
				'A state machine or composite state should have exactly one initial state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				NO_INITIAL
			)
	}

	/* STM3 */
	/* TODO: redundant with @method checkStateMachineHasInitialState? */
	@Check
	def checkStateInitialState(circus.robocalc.robochart.State s) {
		if (s.nodes.size > 0 && s.nodes.filter(Initial).size !== 1)
			warning(
				'A state machine or composite state should have exactly one initial state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				NO_INITIAL
			)
	}

	/* STM4 and (because OperationDef is a NodeContainer) O1:STM4 */
	@Check
	def checkNodeContainerHasStates(NodeContainer c) {
		if (c.nodes.size > 0 && c.nodes.filter [ n |
			n instanceof circus.robocalc.robochart.State || n instanceof Final
		].size === 0)
			error(
				'A composite state should have at least one state or final state',
				RoboChartPackage.Literals.NODE_CONTAINER__NODES,
				COMPOSITE_STATE_WITHOUT_STATE
			)
	}

	/* STM6 */
	@Check
	def wfcSTM6_noOpDeclInStms(StateMachineDef stm) {
		if(!stm.getOperations().isEmpty()) {
			error(
				"STM6: State machines must not have operations declared directly within them",
				RoboChartPackage.Literals.BASIC_CONTEXT__OPERATIONS
			)			
		}
	}

	/* TODO: generalisation of stmDef, to be substituted */
	def Context getContext(ConnectionNode cn) {
		if (cn instanceof StateMachineDef)
			return cn as StateMachineDef
		else if (cn instanceof ControllerDef)
			return cn as ControllerDef
		else if (cn instanceof RoboticPlatformDef)
			return cn as RoboticPlatformDef
		else if (cn instanceof StateMachineRef)
			return cn.ref
		else if (cn instanceof ControllerRef)
			return cn.ref
		else if (cn instanceof RoboticPlatformRef)
			return cn.ref
	}
	
	def stmDef(StateMachine s) {
		if (s instanceof StateMachineRef)
			return s.ref
		else
			s as StateMachineDef
	}

//	@Check
//	def checkRequiredVariables(ControllerDef c) {
//		val rvars = new HashSet<String>() 
//		for (s: c.machines) {
//			for (i: s.stmDef.RInterfaces) {
//				for (vl: i.variableList) {
//					rvars.addAll(vl.vars.map[v|v.name])
//				}				
//			}
//		}
//		val prvars = new HashSet<String>()
//		for (i: c.RInterfaces) {
//			for (vl: i.variableList) {
//				prvars.addAll(vl.vars.map[v|v.name])
//			}				
//		}
//		for (i: c.PInterfaces) {
//			for (vl: i.variableList) {
//				prvars.addAll(vl.vars.map[v|v.name])
//			}
//		}
//		for (vl: c.variableList) {
//			prvars.addAll(vl.vars.map[v|v.name])
//		}
//		if (!(prvars.containsAll(rvars))) {
//			var s = ""
//			var started = false
//			for (v: rvars) {
//				if (!prvars.contains(v)) {
//					if (started) s += ', '
//					s +=  v
//					started = true
//				}
//			}
//			error('A controller should either provide or require all variables required by its state machines. Missing variables: '+s,
//			RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//			"unsatisfiedRequiredVariables")
//		}
//	}
	def ctrlDef(Controller c) {
		if (c instanceof ControllerRef)
			return c.ref
		else
			c as ControllerDef
	}

	def rpDef(RoboticPlatform rp) {
		if (rp instanceof RoboticPlatformRef)
			return rp.ref
		else
			rp as RoboticPlatformDef
	}

	// need to update checkRequiredVariables with type comparison when type checker is working
//
//	@Check
//	def checkRequiredVariables(Module m) {
//		val rvars = new HashSet<String>() 
//		for (c: m.nodes) {
//			if (c instanceof Controller) {
//				for (i: c.ctrlDef.RInterfaces) {
//					for (vl: i.variableList) {
//						rvars.addAll(vl.vars.map[v|v.name])
//					}				
//				}	
//			}
//		}
//		val pvars = new HashSet<String>()
//		for (r: m.nodes) {
//			if (r instanceof RoboticPlatform) {
//				for (i: r.rpDef.PInterfaces) {
//					for (vl: i.variableList) {
//						pvars.addAll(vl.vars.map[v|v.name])
//					}				
//				}
//				for (vl: r.rpDef.variableList) {
//					pvars.addAll(vl.vars.map[v|v.name])
//				}
//			}
//		}
//		if (!(pvars.containsAll(rvars))) {
//			var s = ""
//			var started = false
//			for (v: rvars) {
//				if (!pvars.contains(v)) {
//					if (started) s += ', '
//					s +=  v
//					started = true
//				}
//			}
//			error('Module '+m.name+' does not provide all variables required by its controllers. Missing variables: '+s,
//			RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
//			"unsatisfiedRequiredVariables")
//		}
//	}
	public static val NO_INITIAL_TRANSITION = 'noInitialTransition'

	@Check
	/* IJ2 */
	def initialStateLeadsToState(Initial i) {
		val c = i.eContainer
		val ts = c.eContents.filter(Transition).toList.filter [ t |
			t.source === i
		/* && (t.target instanceof circus.robocalc.robochart.State)*/
		].toList
		if (ts.size !== 1)
			warning(
				'An initial junction must have exactly one outgoing transition',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				NO_INITIAL_TRANSITION
			)
	}

	def inputEvents(StateMachineBody stm) {
		val input = new HashSet<Event>()
		stm.eAllContents.filter(Transition).forEach [ t |
			if(t.trigger !== null && t.trigger.event !== null) input.add(t.trigger.event)
		]
		input
	}

	def outputEvents(StateMachineBody stm) {
		val output = new HashSet<Event>()
		stm.eAllContents.filter(SendEvent).forEach[s|output.add(s.trigger?.event)]
		output
	}

	def StateMachineBody getStateMachineBody(EObject o) {
		if (o instanceof StateMachineBody) {
			return o as StateMachineBody
		} else {
			return o.eContainer.stateMachineBody
		}
	}

	/*@Check
	 * def checkInputEvents(Transition t) {
	 * 	if (t.trigger !== null && t.trigger.event !== null && outputEvents(t.stateMachineBody).contains(t.trigger.event))
	 * 		error('Input event being used as output event',
	 * 			RoboChartPackage.Literals.TRANSITION__TRIGGER,
	 * 			'InputAsOutput'
	 * 		)
	 * }
	 * 
	 * @Check
	 * def checkOutputEvents(SendEvent t) {
	 * 	if (t.trigger !== null && t.trigger.event !== null && inputEvents(t.stateMachineBody).contains(t.trigger?.event))
	 * 		error('Output event being used as input event',
	 * 			RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
	 * 			'OutputAsInput'
	 * 		)
	 * }
	 */
	@Check
	def datatypeHasFields(RecordType d) {
		if (d.fields.size === 0) {
			error(
				'A datatype should have at least one field',
				RoboChartPackage.Literals.RECORD_TYPE__FIELDS,
				'DataTypeWithoutFields'
			)
		}
	}

	@Check
	def tupleHasNatIndex(ArrayExp d) {
		val type = d.value.typeFor
		if (type instanceof ProductType) {
			if (d.parameters.size !== 1) {
				error('Tuple access should contain exactly one index', RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS,
					'TupleIndexNotSingle')
			}
			if (d.parameters.size > 0 && !(d.parameters.get(0) instanceof IntegerExp)) {
				error('Tuple access index should be numeral', RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS,
					'TupleIndexNonNumeral')
			}
			if (d.parameters.size > 0 && d.parameters.get(0) instanceof IntegerExp) {
				val i = (d.parameters.get(0) as IntegerExp).value
				if (i < 1 || i > (type as ProductType).types.size) {
					error('Tuple access index out of range (' + i + ' out of ' + (type as ProductType).types.size + ")",
						RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS, 'TupleIndexOutOfBounds')
				}
			}
		} else if (type instanceof TypeRef && (type as TypeRef).ref instanceof Literal) {
			val c = (type as TypeRef).ref as Literal
			if (c.types.size > 0 && d.parameters.size > 0 && !(d.parameters.get(0) instanceof IntegerExp)) {
				error('Constant access index should be numeral', RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS,
					'ConstantIndexNonNumeral')
			}
			if (d.parameters.size > 0 && d.parameters.get(0) instanceof IntegerExp) {
				val i = (d.parameters.get(0) as IntegerExp).value
				if (i < 1 || i > c.types.size) {
					error('Constant access index out of range (' + i + ' out of ' + c.types.size + ")",
						RoboChartPackage.Literals.ARRAY_EXP__PARAMETERS, 'ConstantIndexOutOfBounds')
				}
			}
		}
	}

	@Check
	def roboticPlatformWFC(RoboticPlatformDef rp) {
		/* RP1 */
		for (i : rp.RInterfaces) {
			error(
				rp.name + ' is a robotic platform and cannot require interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__RINTERFACES,
				'RPNoRequiredInterfaces'
			)
		}
		/* RP2 */
		for (Interface i : rp.interfaces) {
			if (i.variableList.size > 0)
				error(
					getName(rp) + ' cannot define interface ' + i.name + ' because it contains variables',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'UsedInterfaceWithOnlyEvents'
				)
		}
	}

	@Check
	/* O1:STM1 */
	def operationDefWFC(OperationDef o) {
		for (i : o.PInterfaces) {
			error(
				o.name + ' is an operation definition and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'OperationNoProvidedInterfaces'
			)
		}
	}

	@Check
	def requiredWFC(Context c) {
		/* I1 */
		for (i : c.RInterfaces) {
			if (i.events.size > 0) {
				error(
					getName(c) + ' cannot require interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'RequiredInterfaceWithEvents'
				)
			}
		}

		/* I1 */
		for (i : c.PInterfaces) {
			if (i.events.size > 0) {
				error(
					getName(c) + ' cannot provide interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'ProvidedInterfaceWithEvents'
				)
			}
		}

		/* I2, together with I2 implies STM2 and (because OperationDef is a Context) O1:STM2 */
		for (Interface i : c.interfaces) {
			if (i.operations.size > 0)
				error(
					getName(c) + ' cannot define interface ' + i.name + ' because it contains operations',
					RoboChartPackage.Literals.CONTEXT__INTERFACES,
					'UsedInterfaceWithOnlyEvents'
				)
		}
	}

	@Check
	def controllerWFC(ControllerDef c) {
		val opcount = new HashMap<OperationDef,Integer>()
		for (o: c.LOperations) {
			val def = if (o instanceof OperationRef) o.ref else o as OperationDef
			val cnt = opcount.getOrDefault(def,0)
			opcount.put(def,cnt+1)
		}
		val mdef = opcount.filter[p1, p2| p2 > 1]
		if (!mdef.empty) {
			error(
				'''The controller «c.name» declares multiple copies of the same operations: «FOR o: mdef.keySet SEPARATOR ","»«o.name»«ENDFOR»''',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ControllerMultipleReferencesToOperation'
			)
		}
		
		
		/* C2 */
		for (i : c.PInterfaces) {
			error(
				c.name + ' is a controller and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'ControllerNoRequiredInterfaces'
			)
		}
		/* C1 */
		if (c.machines.filter[m|m instanceof StateMachine].size === 0) {
			error(
				c.name + ' must have at least one state machine',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ControllerHasOneOrMoreStateMachines'
			)
		}
		/* TODO: C2+C4? */
		if (c.operations.filter[o|!(o instanceof OperationDef) && !(o instanceof OperationRef)].size > 0) {
			error(
				getName(c) + ' cannot declare operations outside interfaces',
				RoboChartPackage.Literals.BASIC_CONTEXT__OPERATIONS,
				'NoOpsOutsideInterfacesInController'
			)
		}

		val pVars = getPVars(c)
		val pOps = getPOps(c)
		val machines = new HashSet<EObject>();
		machines.addAll(c.machines)
		//machinesAndOperations.addAll(c.LOperations)
		for (s : machines) {
			/* C3 */
			val rVars = getRVars(s)
			if (!pVars.containsAll(rVars)) {
				var vs = ""
				var started = false
				for (v : rVars) {
					if (!pVars.contains(v)) {
						if(started) vs += ', '
						vs += v.name
						started = true
					}
				}
				error(
					c.name + ' does not provide all variables required by ' + getName(s) + ' (missing variables: ' +
						vs + ')',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ControllerProvidesAllVars'
				)
			}
			/* C4 */
			val rOps = getROps(s)
			if (!pOps.containsAll(rOps)) {
				error(
					c.name + ' does not provide all operations required by ' + getName(s),
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ControllerProvidesAllOps'
				)
			}
		}
	}
	
	def Boolean OpEqual(OperationSig sig, Operation op) {
		val OperationDef def = if (op instanceof OperationRef) op.ref else op as OperationDef;
		if (!def.name.equals(sig.name)) return false;
		if (sig.parameters.size != def.parameters.size) return false;
		for (var i = 0; i < sig.parameters.size; i++) {
			val par1 = sig.parameters.get(i);
			val par2 = def.parameters.get(i);
			if (!par1.equals(par2)) return false;
		}
		return true;
	}

	/* STM1, together with I2 implies STM2 and (because OperationDef is a Context) O1:STM2 */
	@Check
	def stmWFC(StateMachineDef c) {
		for (i : c.PInterfaces) {
			error(
				c.name + ' is a state machine and cannot provide interface ' + i.name,
				RoboChartPackage.Literals.CONTEXT__PINTERFACES,
				'StateMachineNoProvidedInterfaces'
			)
		}
		
		if (c.eContainer instanceof ControllerDef) {
			val operations = new HashSet<OperationDef>();
			val parent = c.eContainer as ControllerDef;
			val pVars = getPVars(c);
			val pOps = getPOps(c);
			c.eAllContents.filter(Call).forEach[x|
				val sig = x.operation;
				val op = parent.LOperations.findFirst[y|OpEqual(sig,y)]
				if (op !== null) {
					if (op instanceof OperationRef) 	
						operations.add(op.ref)
					else operations.add(op as OperationDef)
				} 
			]
			for (s : operations) {
				/* C3 */
				val rVars = getRVars(s)
				if (!pVars.containsAll(rVars)) {
					var vs = ""
					var started = false
					for (v : rVars) {
						if (!pVars.contains(v)) {
							if(started) vs += ', '
							vs += v.name
							started = true
						}
					}
					error(
						c.name + ' does not provide all variables required by call to operation ' + getName(s) + ' (missing variables: ' + vs + ')',
						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
						'ControllerProvidesAllVars'
					)
				}
				/* C4 */
				val rOps = getROps(s)
				if (!pOps.containsAll(rOps)) {
					error(
						c.name + ' does not provide all operations required by ' + getName(s),
						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
						'ControllerProvidesAllOps'
					)
				}
			
			}
			
		}
		
	}
	
	@Check
	def stmRefWFC(StateMachineRef c) {
		if (c.eContainer instanceof ControllerDef) {
			val operations = new HashSet<OperationDef>();
			val parent = c.eContainer as ControllerDef;
			val pVars = getPVars(c);
			val pOps = getPOps(c);
			c.ref.eAllContents.filter(Call).forEach[x|
				val sig = x.operation;
				val op = parent.LOperations.findFirst[y|OpEqual(sig,y)]
				if (op !== null) {
					if (op instanceof OperationRef) 	
						operations.add(op.ref)
					else operations.add(op as OperationDef)
				} 
			]
			for (s : operations) {
				/* C3 */
				val rVars = getRVars(s)
				if (!pVars.containsAll(rVars)) {
					var vs = ""
					var started = false
					for (v : rVars) {
						if (!pVars.contains(v)) {
							if(started) vs += ', '
							vs += v.name
							started = true
						}
					}
					error(
						c.name + ' in the context of the controller ' + parent.name + ' does not provide all variables required by call to operation ' + getName(s) + ' (missing variables: ' + vs + ')',
						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
						'ControllerProvidesAllVars'
					)
				}
				/* C4 */
				val rOps = getROps(s)
				if (!pOps.containsAll(rOps)) {
					error(
						c.name + ' in the context of the controller ' + parent.name + ' does not provide all operations required by ' + getName(s),
						RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
						'ControllerProvidesAllOps'
					)
				}
			
			}
			
		}
	}

	def List<Variable> getPVars(EObject o) {
		if (o instanceof RoboticPlatformDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.PInterfaces.forEach [ i |
				i.variableList.forEach [ l |
					pVars.addAll(l.vars)
				]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			return pVars
		} else if (o instanceof RoboticPlatformRef) {
			return getPVars(o.ref)
		} else if (o instanceof ControllerDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			// any controller required variable is provided to the state machines
			return pVars
		} else if (o instanceof ControllerRef) {
			return getPVars(o.ref)
		} else if (o instanceof StateMachineDef) {
			val pVars = new LinkedList<Variable>()
			o.variableList.forEach[l|pVars.addAll(l.vars)]
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			o.interfaces.forEach [ i |
				i.variableList.forEach[l|pVars.addAll(l.vars)]
			]
			return pVars
		} else if (o instanceof StateMachineRef) {
			return getPVars(o.ref)
		}
	}

	def List<OperationSig> getPOps(EObject o) {
		if (o instanceof RoboticPlatformDef) {
			val pOps = new LinkedList<OperationSig>()
			pOps.addAll(o.operations)
			o.PInterfaces.forEach[i|pOps.addAll(i.operations)]
			return pOps
		} else if (o instanceof RoboticPlatformRef) {
			return getPOps(o.ref)
		} else if (o instanceof ControllerDef) {
			val pOps = new LinkedList<OperationSig>()

			// TODO: review this case as it involves operation definitions
			o.LOperations.filter[m|m instanceof OperationDef || m instanceof OperationRef].forEach [ m |
				if(m instanceof OperationRef) pOps.add(m.ref) else pOps.add(m as OperationSig)
			]
			// any controller required operation is provided to the state machines
			o.RInterfaces.forEach[i|pOps.addAll(i.operations)]
			// any operation defined inside a controller, is provided to the state machines
			return pOps
		} else if (o instanceof ControllerRef) {
			return getPOps(o.ref)
		} else if (o instanceof StateMachineDef) {
			// any state machine required operation is provided to the state machine behaviours
			val pOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|pOps.addAll(i.operations)]
			return pOps
		} else if (o instanceof StateMachineRef) {
			return getPOps(o.ref)
		}
	}

	def List<Variable> getRVars(EObject o) {
		if (o instanceof RoboticPlatform) {
			throw new RuntimeException(
				"Robotic Platform do not require variables, therefore this call should not happen")
		} else if (o instanceof ControllerDef) {
			val rVars = new LinkedList<Variable>()
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|rVars.addAll(l.vars)]
			]
			return rVars
		} else if (o instanceof ControllerRef) {
			return getRVars(o.ref)
		} else if (o instanceof StateMachineDef) {
			val rVars = new LinkedList<Variable>()
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|rVars.addAll(l.vars)]
			]
			return rVars
		} else if (o instanceof StateMachineRef) {
			return getRVars(o.ref)
		} else if (o instanceof OperationDef) {
			val rVars = new LinkedList<Variable>()
			o.RInterfaces.forEach [ i |
				i.variableList.forEach[l|rVars.addAll(l.vars)]
			]
			return rVars
		} else if (o instanceof OperationRef) {
			return getRVars(o.ref)
		}
	}

	def List<OperationSig> getROps(EObject o) {
		if (o instanceof RoboticPlatform) {
			throw new RuntimeException(
				"Robotic Platform do not require variables, therefore this call should not happen")
		} else if (o instanceof ControllerDef) {
			val rOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|rOps.addAll(i.operations)]
			return rOps
		} else if (o instanceof ControllerRef) {
			return getROps(o.ref)
		} else if (o instanceof StateMachineDef) {
			val rOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|rOps.addAll(i.operations)]
			return rOps
		} else if (o instanceof StateMachineRef) {
			return getROps(o.ref)
		} else if (o instanceof OperationDef) {
			val rOps = new LinkedList<OperationSig>()
			o.RInterfaces.forEach[i|rOps.addAll(i.operations)]
			return rOps
		} else if (o instanceof OperationRef) {
			return getROps(o.ref)
		}
	}

	@Check
	def moduleWFC(RCModule m) {
		/* M1 */
		val rp = m.nodes.findFirst[n|n instanceof RoboticPlatform]
		if (rp === null || m.nodes.filter[n|n instanceof RoboticPlatform].size > 1) {
			error(
				m.name + ' must have exactly one robotic platform',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'NotUniqueRoboticPlatform'
			)
		}

		if (m.nodes.filter[x|x instanceof Controller].size === 0) {
			error(
				m.name + ' must have at least one controller',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ModuleHasOneOrMoreControllers'
			)
		}

		if (m.nodes.filter[x|x instanceof StateMachine].size > 0) {
			error(
				m.name + ' must not have a state machine outside a controller',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'ModuleHasNoStateMachines'
			)
		}

		/* M2 */
		// need to update checkRequiredVariables with type comparison when type checker is working
		val pVars = getPVars(rp)
		val pOps = getPOps(rp)
		for (c : m.nodes.filter[n|n instanceof Controller]) {
			val rVars = getRVars(c)
			if (!pVars.containsAll(rVars)) {
				var s = ""
				var started = false
				for (v : rVars) {
					if (!pVars.contains(v)) {
						if(started) s += ', '
						s += v.name
						started = true
					}
				}
				error(
					m.name + ' does not provide all variables required by ' + getName(c) + '(missing variables: ' + s +
						')',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ModuleProvidesAllVars'
				)
			}
			val rOps = getROps(c)
			if (!pOps.containsAll(rOps)) {
				error(
					m.name + ' does not provide all operations required by ' + getName(c),
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'ControllerProvidesAllOps'
				)
			}
		}
	}

	/* I2 */
	@Check
	def interfaceEitherEventsOrOthers(Interface d) {
		if (d.events.size > 0 && d.operations.size > 0) {
			error(
				'Aside from variables, an interface should have either events or operations',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'InterfaceEitherEventsOrOthers'
			)
		}
	}

	def getName(EObject o) {
		if (o instanceof ControllerDef)
			o.name
		else if (o instanceof ControllerRef)
			o.ref.name
		else if (o instanceof StateMachineDef)
			o.name
		else if (o instanceof StateMachineRef)
			o.ref.name
		else if(o instanceof NamedElement) o.name else null
	}

	/* I1 */
	@Check
	def interfaceEitherEventsOrOthers(Context d) {
		for (Interface i : d.RInterfaces) {
			if (i.events.size > 0)
				error(
					getName(d) + ' cannot require interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__RINTERFACES,
					'RequiredInterfaceWithoutEvents'
				)
		}
		for (Interface i : d.PInterfaces) {
			if (i.events.size > 0)
				error(
					getName(d) + ' cannot provide interface ' + i.name + ' because it contains events',
					RoboChartPackage.Literals.CONTEXT__PINTERFACES,
					'ProvidedInterfaceWithoutEvents'
				)
		}
	}

	// Timed validation rules
//	@Check
//	def clockExpComparedWithWithCall(CallExp e) {
//		if (e.eContainer !== null) {
//			
//		}
//	}
//	
//	def boolean isClockExp(Expression e) {
//		switch e {
//			Plus: 	e.left.isClockExp && e.right.isClockExp
//			Minus: 	e.left.isClockExp && e.right.isClockExp
//			Mult: 	e.left.isClockExp && e.right.isClockExp
//			Div:	 e.left.isClockExp && e.right.isClockExp
//			Modulus : e.left.isClockExp && e.right.isClockExp
//		}
//	}
//	
//	def dispatch boolean isParentComparisonWithClock(Expression e) {
//		switch e {
//			GreaterThan : e.left.isClockExp || e.right.isClockExp
//			default : e.eContainer.isParentComparisonWithClock
//		}
//	}
//	
//	def dispatch boolean isParentComparisonWithClock(EObject e) {
//		return false
//	}
	/* Helper for TE4 */
	def boolean isConstantExp(Expression e) {
		switch e {
			RefExp: {
				var n = e.ref
				return switch n {
					Variable: {
						(n.modifier === VariableModifier.CONST)
					}
					Literal:
						true
					default:
						false
				}
			}
			IntegerExp:
				true
			CallExp: {
				var isConstant = true
				for (arg : e.args) {
					isConstant = isConstant && arg.isConstantExp
				}
				return isConstant
			}
			Plus:
				e.left.isConstantExp && e.right.isConstantExp
			Minus:
				e.left.isConstantExp && e.right.isConstantExp
			Mult:
				e.left.isConstantExp && e.right.isConstantExp
			Div:
				e.left.isConstantExp && e.right.isConstantExp
			Modulus:
				e.left.isConstantExp && e.right.isConstantExp
			ArrayExp:
				e.value.isConstantExp
			ParExp:
				e.exp.isConstantExp
			default:
				false
		}
	}

	/* SCE2, covers TE4 for sinceEntry(state) */
	@Check
	def clockExpOnlySupportedComparator(StateClockExp e) {
		checkClockExpWellTyped(e)
		clockExpOnlySupported(e)
	}

	/* CE2, covers TE4 for since(clock) */
	@Check
	def clockExpOnlySupportedComparator(ClockExp e) {
		checkClockExpWellTyped(e)
		clockExpOnlySupported(e)
	}

	/* TE4 (helper) */
	def checkClockExpWellTyped(Expression e) {
		val nat = getNatType(e)
		val real = getRealType(e)

		if (e.eContainer !== null && e.eContainer instanceof Expression) {
			var parent = e.eContainer
			var isTypeCompatible = false

			switch parent {
				LessThan: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				LessOrEqual: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				GreaterThan: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				GreaterOrEqual: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				Equals: {
					isTypeCompatible = if (parent.left === e) {
						var compareType = parent.right.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					} else {
						var compareType = parent.left.typeFor
						if (compareType !== null)
							typeCompatible(compareType, nat) || typeCompatible(compareType, real)
						else
							false
					}
				}
				default:
					error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
			}
			if (!isTypeCompatible) {
				error('Timed expression being compared should be of type nat or real', null, 'TimeExpressionTypeError',
					'timed')
			}
		} else {
			error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
		}
	}

	/* TE4 (part for checking comparison to constant) */
	def clockExpOnlySupported(Expression e) {
		if (e.eContainer !== null && e.eContainer instanceof Expression) {
			var parent = e.eContainer
			var isconstant = false
			switch parent {
				LessThan: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				LessOrEqual: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				GreaterThan: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				GreaterOrEqual: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				Equals: {
					isconstant = if (parent.left === e) {
						parent.right.isConstantExp
					} else {
						parent.left.isConstantExp
					}
				}
				default:
					error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
			}
			if (!isconstant) {
				warning('Timed expression is not constant', null, 'TimeExpressionNotConstant', 'timed')
			}
		} else {
			error('Unsupported use of timed expression', null, 'TimeExpressionNotSupported', 'timed')
		}
	}

	/* TE1' (covers "TE1: since and sinceEntry only in transition guards" and CE1/SCE1) */
	// Expressions such as
	@Check
	def statementNoTimedExpressions(Expression e) {
		if (e !== null && (e instanceof ClockExp || e instanceof StateClockExp) && e.expressionInStatement) {
			error('Timed expression not allowed in action', null)
		}
	}

	def dispatch boolean expressionInStatement(Statement s) {
		return true
	}

	def dispatch boolean expressionInStatement(EObject obj) {
		if (obj.eContainer !== null) {
			return expressionInStatement(obj.eContainer)
		} else {
			return false
		}
	}
	
	/* TE2 */
	@Check
	def wfcTE2_NoForeignClock(ClockExp ce) {
		val stm = identifyContainingStateMachineBody(ce)
		if (!stm.clocks.contains(ce.clock)) {
			error("TE2: The clock in " + print(ce) 
				+ " is not declared within state machine " + stm.name,
			 	RoboChartPackage.Literals.CLOCK_EXP__CLOCK,
			 	"NoForeignClock"
			)
		}
	}

	/* Helper for TE3 (termination requires on absence of loops in node hierarchy) */
	def BasicEList<circus.robocalc.robochart.State> identifyNestedStates(NodeContainer nc) {
		val nestedStates = new BasicEList<circus.robocalc.robochart.State>
		for (n : nc.nodes) {
			if (n instanceof circus.robocalc.robochart.State) {
				nestedStates.addAll(identifyNestedStates(n as NodeContainer))
			 	nestedStates.add(n as circus.robocalc.robochart.State)
		 	}
	 	} 
		nestedStates
	}

	/* TE3 */
	@Check
	def wfcTE3_NoForeignState(StateClockExp sce) {
		val stm =  identifyContainingStateMachineBody(sce)
		val nestedStates = identifyNestedStates(stm)
		if (sce.state !== null && !nestedStates.contains(sce.state)) {
			error("TE3: The state in " + print(sce) 
				+ " is not declared within state machine " + stm.name,
			 	RoboChartPackage.Literals.STATE_CLOCK_EXP__STATE,
			 	"NoForeignState"
			)
		}
	}
	
	@Check
	def wfcCn_EventsFromSameContext(Connection c) {
		var cont = c.eContainer
		/* Cn1 (approximation via to/from) */
		if (cont instanceof RCModule) {
			if (!(cont.nodes.contains(c.to) && cont.nodes.contains(c.from))) {
				error('Cn1: Connections of a module must associate only its robotic platform and its controllers',
					RoboChartPackage.Literals.CONNECTION__EFROM, 
					'NodesNotFromSameModule')
			}
		}
			
		/* Cn3 (approximation via to/from) */
		if (cont instanceof ControllerDef) {
			var nodes = new LinkedList<ConnectionNode>
			nodes.add(cont) 
			nodes.addAll(cont.machines)
			if (!(nodes.contains(c.to) && nodes.contains(c.from))) {
				error('Cn3: Connections of a controller must associate only itself and its state machines',
					RoboChartPackage.Literals.CONNECTION__EFROM, 
					'NodesNotFromSameController')
			}
		}
		 
		/* Cn10 */
		// identify context and collect set of events of this context for to/from
		val toEvents = new LinkedList<Event>()
		toEvents.addAll(getContext(c.to).events)
		getContext(c.to).interfaces.forEach[i | toEvents.addAll(i.events)]
		// check whether eto is in this list
		if (!toEvents.contains(c.eto)) {
			error('Cn10: The eto-event of a connection must be an event of its to-node',
				RoboChartPackage.Literals.CONNECTION__ETO, 
				'ToEventFromForeignContext')
		}
		val fromEvents = new LinkedList<Event>()
		fromEvents.addAll(getContext(c.from).events)
		getContext(c.from).interfaces.forEach[i | fromEvents.addAll(i.events)]
		// check whether efrom is in this list
		if (!fromEvents.contains(c.efrom)) {
			error('Cn10: The efrom-event of a connection must be an event of its from-node',
				RoboChartPackage.Literals.CONNECTION__EFROM, 
				'FromEventFromForeignContext')
		}
	}

	@Check
	def rpConnectionAsync(Connection c) {
		// if either end of the connection is a robotic platform,
		// the connections is asynchronous, but it should not be
		// marked as such
		/* Cn2 */
		if (c.to instanceof RoboticPlatform || c.from instanceof RoboticPlatform) {
			val rp = if(c.to instanceof RoboticPlatform) c.to else c.from
			val msg = 'The connection between event ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name +
				' on ' + getName(rp) + '  must be asynchronous'
			if (!c.async) {
				error(msg, RoboChartPackage.Literals.CONNECTION__ASYNC, 'RPConnectionAsync')
			}
		}
		if ((c.from instanceof StateMachine && c.to instanceof StateMachine) || (c.from instanceof Controller &&
			c.to instanceof Controller)) {
			if (c.eto.isBroadcast || c.efrom.isBroadcast) {
				error('A connection of broadcast events should be a relay between different constructs',
					RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionBroadcasstNotRelay')
			}
		}
		/* Cn4 */
		if (c.efrom.broadcast !== c.eto.broadcast) {
			error(
				'Connected events must be both broadcast, or both non-broadcast events',
				RoboChartPackage.Literals.CONNECTION__EFROM,
				'RPConnectionBroadcast'
			)
		}
		if (c.efrom.type !== null && c.eto.type !== null && !typeCompatible(c.efrom.type, c.eto.type)) {
			val msg = 'The events ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name + ' on ' +
				getName(c.to) + ' have incompatible types'
			error(msg, RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionIncompatibleType')
		} else if (c.efrom.type === null && c.eto.type !== null) {
			val msg = 'The events ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name + ' on ' +
				getName(c.to) + ' have incompatible types'
			error(msg, RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionIncompatibleType')
		} else if (c.efrom.type !== null && c.eto.type === null) {
			val msg = 'The events ' + c.efrom.name + ' on ' + getName(c.from) + ' and ' + c.eto.name + ' on ' +
				getName(c.to) + ' have incompatible types'
			error(msg, RoboChartPackage.Literals.CONNECTION__EFROM, 'RPConnectionIncompatibleType')
		}
	}

	/* RP3, I3, C5, STM5, O1:STM5 */
	@Check(CheckType.FAST)
	def checkUniqueness(NamedElement o) {
		val project = o.eResource.URI.segment(1)
		val c = new LinkedList<IEObjectDescription>()
		val qn = qnp.getFullyQualifiedName(o)
		rds.allResourceDescriptions.filter[rd|rd.URI.segment(1) === project].forEach [ rd |
			c.addAll(rd.getExportedObjects(o.eClass, qn, false).toList)
		]
		val s = c.size
		if (s > 1) {
			warning(
				qn.toString("::") + ' is not unique',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'UniqueQualifiedName'
			)
		}
	}

	@Check
	def variableInitWellTyped(Variable v) {
		if (v.initial !== null) {
			val t1 = v.initial.typeFor
			val t2 = v.type
			if (!typeCompatible(t1, t2)) {
				val parent = if (v.eContainer.eContainer instanceof NamedElement)
						(v.eContainer.eContainer as NamedElement).
							name
					else
						null
				val msg = '''Variable «v.name» «(if(parent !== null) 'in ' + parent else '')» expects type «v.type.printType», but «IF t1 === null»expression cannot be typed.«ELSE»expression has type «t1.printType»«ENDIF»'''

				error(
					msg,
					RoboChartPackage.Literals.VARIABLE__INITIAL,
					'VarInitType'
				)
			}
		}
	}

//	def dispatch String print(Assignable a) {
//		switch (a) {
//			VarRef:
//				return a.name.name
//			VarSelection:
//				return (a.receiver.print + "." + a.member.name)
//			ArrayAssignable: {
//				var s = a.value.print + "["
//				if (a.parameters.size > 0) {
//					s += a.parameters.get(0).print
//					for (var i = 1; i < a.parameters.size; i++) {
//						s += ", " + a.parameters.get(i).print
//					}
//				}
//				s += "]"
//				return s
//			}
//		}
//	}
	@Check
	def assignmentWellTyped(Assignment a) {
		val t2 = a.left.typeFor
		val t1 = a.right.typeFor
		if (!typeCompatible(t1, t2)) { // && t1 !==	null) { I had to remove this otherwise an badly typed expression would not yield an error
			val msg = '''Variable «a.left.print» expects type «a.left.typeFor.printType», but «IF t1 === null»expression cannot be typed.«ELSE»expression has type «t1.printType»«ENDIF» '''
			error(
				msg,
				RoboChartPackage.Literals.ASSIGNMENT__LEFT,
				'AssignmentTypeError'
			)
		}
	}

	@Check
	def ifStmtWellTyped(IfStmt ifstmt) {
		val bool = getBooleanType(ifstmt)
		val tcond = ifstmt.expression.typeFor
		if (!typeCompatible(tcond, bool)) {
			val msg = 'Condition of if statement should have type boolean, but ' +
				if(tcond === null) 'actual type could not be computed' else 'actual type is ' + tcond.printType
			error(
				msg,
				RoboChartPackage.Literals.IF_STMT__EXPRESSION,
				'IfStmtTypeError'
			)
		}
	}

	@Check
	def waitWellTyped(Wait w) {
		val integer = getIntType(w)
		val setInt = RoboChartFactory.eINSTANCE.createSetType
		setInt.domain = EcoreUtil2.copy(integer)
		val t = w.duration.typeFor
		if (!typeCompatible(t, integer) && !typeCompatible(t, setInt)) {
			error(
				'Parameter of wait should be an integer or a set of integers',
				RoboChartPackage.Literals.WAIT__DURATION,
				'WaitTypeError'
			)
		}
	}

	@Check
	def callWellTyped(Call c) {
		val op = c.operation
		val opSig = if(op instanceof OperationRef) op.ref as OperationSig else op as OperationSig
		if (opSig.parameters.size !== c.args.size) {
			error(
				'Incorrect number of parameters in operation call',
				RoboChartPackage.Literals.CALL__ARGS,
				'OperationWrongNumberofParameters'
			)
		} else {
			for (var i = 0; i < opSig.parameters.size; i++) {
				val argtype = c.args.get(i).typeFor
				if (!typeCompatible(argtype, opSig.parameters.get(i).type)) {
					error(
						'Parameter ' + i + ' of the operation ' + opSig.name + ' expects type ' +
							opSig.parameters.get(i).type.printType + ', but argument has type ' + argtype.printType,
						RoboChartPackage.Literals.CALL__ARGS,
						'CallArgumentTypeError'
					)
				}
			}
		}
	}

	@Check
	def sendEventWFC(SendEvent s) {
		if (s.trigger.time !== null) {
			error('A send action cannot have a time associated with it', RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
				'NoTimeInSendEvent');
		}
		if (s.trigger.reset !== null && s.trigger.reset.length > 0) {
			error('A send action cannot have a reset associated with it', RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
				'NoResetInSendEvent');
		}
		if (s.trigger._type === TriggerType.EMPTY) {
			error('A send action cannot have an empty trigger', RoboChartPackage.Literals.SEND_EVENT__TRIGGER,
				'NoEmptyTriggerInSendEvent');
		}
	}

	@Check
	def triggerWellTyped(Trigger t) {
		/* Tg1 */
		// Violation is currently not possible because the syntax (editors) doesn't allow the creation of such objects
		if (t._type === TriggerType.SIMPLE) {
			if (t.parameter !== null) {
				error(
					'A simple trigger should not specify a parameter attribute',
					RoboChartPackage.Literals.TRIGGER__PARAMETER,
					'NoParametersForSimpleTriggers'
				)							
			}
			if (t.value !== null) {
				error(
					'A simple trigger should not specify a value attribute',
					RoboChartPackage.Literals.TRIGGER__VALUE,
					'NoValueForSimpleTriggers'
				)							
			}
		}
		/* Tg5 */
		if ((t._type === TriggerType.INPUT || t._type === TriggerType.OUTPUT || t._type === TriggerType.SYNC) &&
			t.event.type === null) {
			error(
				'An input, output or sync trigger must refer to a typed event. See ' + t.event.name,
				RoboChartPackage.Literals.TRIGGER__EVENT,
				'TypedEventRequired'
			)
		}
		/* Tg2 */
		if ((t._type === TriggerType.SIMPLE) && t.event.type !== null) {
			error(
				'A simple trigger must refer to an untyped event. See ' + t.event.name,
				RoboChartPackage.Literals.TRIGGER__EVENT,
				'UntypedEventRequired'
			)
		}
		/* Tg3 */
		if (t._type === TriggerType.INPUT && (t.parameter === null || t.value !== null)) {
			error(
				'An input trigger must have a parameter, not a value',
				RoboChartPackage.Literals.TRIGGER__EVENT,
				'InputParameterError'
			)
		}
		/* Tg4 */
		if (t._type === TriggerType.OUTPUT && (t.parameter !== null || t.value === null)) {
			error(
				'An output trigger must have a value, not a parameter',
				RoboChartPackage.Literals.TRIGGER__EVENT,
				'OutputParameterError'
			)
		}
		/* Tg4 */
		if (t._type === TriggerType.SYNC && (t.parameter !== null || t.value === null)) {
			error(
				'An synchronisation trigger must have a value, not a parameter',
				RoboChartPackage.Literals.TRIGGER__EVENT,
				'SyncParameterError'
			)
		}

		if (t._type === TriggerType.INPUT) {
			val t1 = t.parameter.type
			val t2 = t.event.type
			if (!typeCompatible(t1, t2)) {
				error(
					'Event ' + t.event.name + ' expects type ' + t2.printType + ', but input parameter has type ' +
						t1.printType,
					RoboChartPackage.Literals.TRIGGER__PARAMETER,
					'InputTriggerTypeError'
				)
			}
		} else if (t._type === TriggerType.OUTPUT) {
			val t1 = t.value.typeFor
			val t2 = t.event.type
			if (!typeCompatible(t1, t2)) {
				error(
					'Event ' + t.event.name + ' expects type ' + t2.printType + ', but output value has type ' +
						t1.printType,
					RoboChartPackage.Literals.TRIGGER__VALUE,
					'OutputTriggerTypeError'
				)
			}
		} else if (t._type === TriggerType.SYNC) {
			val t1 = t.value.typeFor
			val t2 = t.event.type
			if (!typeCompatible(t1, t2)) {
				error(
					'Event ' + t.event.name + ' expects type ' + t2.printType +
						', but synchronisation value has type ' + t1.printType,
					RoboChartPackage.Literals.TRIGGER__VALUE,
					'SyncTriggerTypeError'
				)
			}
		} else if (t._type === TriggerType.SIMPLE) {
			if (t.event.type !== null) {
				error(
					'Event ' + t.event.name + ' expects a value of type ' + t.event.type.printType,
					RoboChartPackage.Literals.TRIGGER__EVENT,
					'SimpleTriggerTypeError'
				)
			}
		}
	}

	@Check
	def transitionWellTyped(Transition t) {
		val bool = getBooleanType(t)
		val tcond = t.condition?.typeFor
		if (t.condition !== null && !typeCompatible(tcond, bool)) {
			val msg = 'Transition condition should have type boolean, but ' + (if (tcond === null)
				'actual type could not be computed'
			else
				'actual type is ' + tcond.printType)
			error(
				msg,
				RoboChartPackage.Literals.TRANSITION__CONDITION,
				'TransitionConditionTypeError'
			)
		}
	}

	@Check
	def constantWellTyped(RefExp e) {
		if (e.ref instanceof Literal && !(e.eContainer instanceof CallExp)) {
			val c = e.ref as Literal
			if (c.types.size > 0) {
				error(
					"Constant " + c.name + " expects " + c.types.size + " arguments, but call provides none",
					RoboChartPackage.Literals.REF_EXP__REF,
					'IncorrectNumberOfArguments'
				)
				return
			}
		}
	}

	@Check
	def constantConstructionWellTyped(CallExp e) {
		val t = e.function.typeFor
		if (t instanceof TypeRef && (t as TypeRef).ref instanceof Enumeration) {
			val variant = (e.function as RefExp).ref as Literal // a variant is interpreted as a constructor function
			if (variant.types.size === 0) {
				warning(
					"Constructor " + variant.name + " has no parameter. Avoid using a call.",
					RoboChartPackage.Literals.CALL_EXP__FUNCTION,
					'ParameterlessConstructorWithCall'
				)
				return;
			}

			if (variant.types.size !== e.args.size) // wrong number of parameters
			{
				error(
					"Constructor " + variant.name + " expects " + variant.types.size +
						" arguments, but call only provides " + e.args.size,
					RoboChartPackage.Literals.CALL_EXP__FUNCTION,
					'IncorrectNumberOfArguments'
				)
				return;
			}
			val res = e.eResource
			for (var i = 0; i < variant.types.size; i++) {
				var type = variant.types.get(i)

				type = type.rewriteType(res)
				var exp_type = e.args.get(i).typeFor
				exp_type = exp_type.rewriteType(res)
				if (exp_type === null) // one of the parameters cannot be typed
				{
					error(
						"Parameter " + (i + 1) + " of the constructor " + variant.name + " could not be typed",
						RoboChartPackage.Literals.CALL_EXP__FUNCTION,
						'ParameterWithoutType'
					)
					return;
				}

				if (!typeCompatible(exp_type, type)) // one of the parameters has the wrong type
				{
					error(
						"Parameter " + (i + 1) + " of the constructor " + variant.name + " should have type " +
							type.printType + ", but the received value has type " + exp_type.printType,
						RoboChartPackage.Literals.CALL_EXP__FUNCTION,
						'WrontParameterType'
					)
					return;
				}
			}
		}
	}

	@Check
	def functionCallWellTyped(CallExp e) {
		if (e.function instanceof Expression) {
			val t = e.function.typeFor
			if (t instanceof FunctionType) {
				if (t.domain instanceof ProductType) {
					val p = t.domain as ProductType
					if (p.types.size !== e.args.size) {
						val f = e.function.print
						error(
							"Function " + f + " expects  " + p.types.size + " arguments, but call only provides " +
								e.args.size,
							RoboChartPackage.Literals.CALL_EXP__ARGS,
							'IncorrectNumberOfArguments'
						)
						return;
					}
					for (var i = 0; i < p.types.size; i++) {
						val t1 = e.args.get(i).typeFor
						val t2 = p.types.get(i)
						if (!typeCompatible(t1, t2) && t1 !== null) {
							val arg = e.args.get(i).print()
							val f = e.function.print()
							error(
								"Argument " + arg + " of function " + f + " has type " + t1.printType +
									": expected type is " + t2.printType,
								RoboChartPackage.Literals.CALL_EXP__ARGS,
								'UndefinedTypeInArguments'
							)
						}
					}
				} else if (e.args.size === 1) {
					val t1 = e.args.get(0).typeFor
					val t2 = t.domain
					val u = unify(t2, t1)
					val aux = instantiate(t2, u)
					if (!typeCompatible(t1, aux)) {
						val arg = e.args.get(0).print()
						val f = e.function.print()
						error(
							"Argument " + arg + " of function " + f + " has type " + t1.printType +
								": expected type is " + aux.printType,
							RoboChartPackage.Literals.CALL_EXP__ARGS,
							'UndefinedTypeInArguments'
						)
					}
				}
			}
		}
	}

	@Check
	def BroadcastConnectionWFC(Connection c) {
		// only one of the extremities are broadcasts
		if ((c.efrom.broadcast || c.eto.broadcast) && !(c.efrom.broadcast && c.eto.broadcast)) {
			if (!c.efrom.broadcast) {
				error("A broadcast event must be connected to another broadcast event. See " + c.efrom.name + " in " +
					c.from.name, RoboChartPackage.Literals.CONNECTION__EFROM, "Broadcast2NonBroadcast");
			} else if (!c.eto.broadcast) {
				error("A broadcast event must be connected to another broadcast event. See " + c.eto.name + " in " +
					c.to.name, RoboChartPackage.Literals.CONNECTION__ETO, "Broadcast2NonBroadcast");
			}
		}
	}

	@Check
	def moduleOneConnPerEvent(RCModule mod) {
		var eventConn = new HashMap<String, Connection>()

		/* M3 */
		for (conn : mod.connections) {
			val from = qnp.getFullyQualifiedName(conn.from)+"."+conn.efrom.name;
			val to = qnp.getFullyQualifiedName(conn.to)+"."+conn.eto.name;
			if (eventConn.containsKey(from)) {
				error(
					conn.efrom.name + " on " + conn.from.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__EFROM
				)
				eventConn.put(from, conn)
			}

			if (eventConn.containsKey(to)) {
				error(
					conn.eto.name + " on " + conn.to.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__ETO
				)
			} else {
				eventConn.put(to, conn)
			}
		}
	}

	/* C6 */
	@Check
	def controllerOneConnPerEvent(ControllerDef ctrl) {
		var eventConn = new HashMap<String, Connection>()

		for (conn : ctrl.connections) {
			val from = qnp.getFullyQualifiedName(conn.from)+"."+conn.efrom.name;
			val to = qnp.getFullyQualifiedName(conn.to)+"."+conn.eto.name;
//			System.out.println(qnp.getFullyQualifiedName(conn.from));
//			System.out.println(qnp.getFullyQualifiedName(conn.efrom));
//			System.out.println(from);
//			System.out.println(to);
			if (eventConn.containsKey(from)) {
				error(
					conn.efrom.name + " on " + conn.from.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__EFROM
				)
				eventConn.put(from, conn)
			}

			if (eventConn.containsKey(to)) {
				error(
					conn.eto.name + " on " + conn.to.name + " already has a connection",
					conn,
					RoboChartPackage.Literals.CONNECTION__ETO
				)
			} else {
				eventConn.put(to, conn)
			}
		}
	}
	
	/* C7 */
	/* Currently not allowed by the meta-model, hence, ineffective. */
	@Check
	def wfcC7_noOpDeclInCtr(ControllerDef c) {
		if (!c.getOperations().isEmpty()) {
			error(
				"C7: Operations must not be declared directly in a controller, but may be defined in the controller",
				c,
				RoboChartPackage.Literals.BASIC_CONTEXT__OPERATIONS 
			)
		}
	}

	def private HashSet<Event> ncOutputSet(NodeContainer nc) {
		var outputs = new HashSet<Event>()

		for (t : nc.transitions) {
			// need to check trigger and action of each transition, as both may contain a communication
			if (t.trigger !== null && t.trigger.get_type === TriggerType.OUTPUT)
				outputs.add(t.trigger.event)
			if (t.trigger !== null && t.trigger.get_type === TriggerType.SYNC)
				outputs.add(t.trigger.event) // c.x is an output
				// simple event in trigger is always an input
			if(t.action !== null) outputs.addAll(statementOutputSet(t.action))
		}

		for (n : nc.nodes) {
			// outputs from nested nodes must be added
			if(n instanceof NodeContainer) outputs.addAll(ncOutputSet(n))

			// actions in a state may also contain a communication
			if (n instanceof circus.robocalc.robochart.State) {
				for (a : n.actions) {
					if(a.action !== null) outputs.addAll(statementOutputSet(a.action))
				}
			}
		}

		outputs
	}

	def private HashSet<Event> statementOutputSet(Statement s) {
		var outputs = new HashSet<Event>()

		if (s instanceof SendEvent) {
			if (s.trigger !== null && s.trigger.get_type === TriggerType.OUTPUT)
				outputs.add(s.trigger.event)
			if (s.trigger !== null && s.trigger.get_type === TriggerType.SYNC)
				outputs.add(s.trigger.event) // c.x is an output
				// simple event in statement is always an output
			if (s.trigger !== null && s.trigger.get_type === TriggerType.SIMPLE)
				outputs.add(s.trigger.event)
		} else if (s instanceof SeqStatement) {
			for (s2 : s.statements) {
				outputs.addAll(statementOutputSet(s2))
			}
		} else if (s instanceof IfStmt) {
			outputs.addAll(statementOutputSet(s.getThen))
			outputs.addAll(statementOutputSet(s.getElse))
		}

		outputs
	}

	def private HashSet<Event> ncInputSet(NodeContainer nc) {
		var inputs = new HashSet<Event>()

		for (t : nc.transitions) {
			// need to check trigger and action of each transition, as both may contain a communication
			if (t.trigger !== null && t.trigger.get_type === TriggerType.INPUT)
				inputs.add(t.trigger.event)
			// simple event in trigger is always an input
			if (t.trigger !== null && t.trigger.get_type === TriggerType.SIMPLE)
				inputs.add(t.trigger.event)
			if(t.action !== null) inputs.addAll(statementInputSet(t.action))
		}

		for (n : nc.nodes) {
			// inputs from nested nodes must be added
			if(n instanceof NodeContainer) inputs.addAll(ncInputSet(n))

			// actions in a state may also contain a communication
			if (n instanceof circus.robocalc.robochart.State) {
				for (a : n.actions) {
					if(a.action !== null) inputs.addAll(statementInputSet(a.action))

				}
			}
		}

		inputs
	}

	def private HashSet<Event> statementInputSet(Statement s) {
		var inputs = new HashSet<Event>()

		if (s instanceof SendEvent) {
			if (s.trigger !== null && s.trigger.get_type === TriggerType.INPUT)
				inputs.add(s.trigger.event)
		} else if (s instanceof SeqStatement) {
			for (s2 : s.statements) {
				inputs.addAll(statementInputSet(s2))
			}
		} else if (s instanceof IfStmt) {
			inputs.addAll(statementInputSet(s.getThen))
			inputs.addAll(statementInputSet(s.getElse))
		}

		inputs
	}

	@Check
	def checkControllerConnections(ControllerDef ctrl) {
		var index = 0
		for (c : ctrl.connections) {
			if(c.isBidirec) return; // if the connection is bidirectional, then there are no restrictions
			/* Cn9 */
			if (c.from !== ctrl && c.from instanceof StateMachine) {
				if (ncInputSet(stmDef(c.from as StateMachine)).contains(c.efrom)) {
					error(
						c.efrom.name + " on " + c.from.name +
							" is used as the start of a unidirectional connection, but " + c.from.name +
							" receives input on " + c.efrom.name,
						c,
						RoboChartPackage.Literals.CONNECTION__FROM,
						index
					)

				}
			}

			/* Cn8 */
			if (c.to !== ctrl && c.to instanceof StateMachine) {
				if (ncOutputSet(stmDef(c.to as StateMachine)).contains(c.eto)) {
					error(
						c.eto.name + " on " + c.to.name + " is used as the end of a unidirectional connection, but " +
							c.to.name + " outputs on " + c.eto.name,
						c,
						RoboChartPackage.Literals.CONNECTION__TO,
						index
					)
				}
			}

			index++
		}
	}

	def Connection getControllerConnection(ControllerDef ctrl, Event e) {
		for (conn : ctrl.connections) {
			if((conn.from === ctrl && conn.efrom === e) || (conn.to === ctrl && conn.eto === e)) return conn
		}

		return null
	}

	@Check
	def checkModuleConnections(RCModule mod) {
		var index = 0

		for (c : mod.connections) {
			if (c.isBidirec) {
				/* Cn5 */
				// if the connection is bidirectional, controller connections to the events must be bidirectional
				if (c.to instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.to as Controller), c.eto)
					if (ctrlConn !== null && !ctrlConn.isBidirec) {
						error(
							c.eto.name + " on " + c.to.name +
								" is used as the end of a bidirectional connection, but " + c.to.name +
								" does not contain a bidirectional connection to " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					}
				}

				if (c.from instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.from as Controller), c.efrom)
					if (ctrlConn !== null && !ctrlConn.isBidirec) {
						error(
							c.efrom.name + " on " + c.efrom.name +
								" is used as the end of a bidirectional connection, but " + c.from.name +
								" does not contain a bidirectional connection to " + c.efrom.name,
							c,
							RoboChartPackage.Literals.CONNECTION__FROM,
							index
						)
					}
				}

			} else {
				/* Cn6 */
				// otherwise, the direction of the controller connections to the event must be consistent
				if (c.to instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.to as Controller), c.eto)
					if (ctrlConn !== null && ctrlConn.isBidirec) {
						error(
							c.eto.name + " on " + c.to.name +
								" is used as the end of a unidirectional connection, but " + c.to.name +
								" contains a bidirectional connection to " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					} else if (ctrlConn !== null && ctrlConn.from !== ctrlDef(c.to as Controller)) {
						error(
							c.eto.name + " on " + c.to.name +
								" is used as the end of a unidirectional connection, but " + c.to.name +
								" contains a connection to " + c.eto.name,
							c,
							RoboChartPackage.Literals.CONNECTION__TO,
							index
						)
					}
				}
				
				/* Cn7 */
				if (c.from instanceof Controller) {
					val ctrlConn = getControllerConnection(ctrlDef(c.from as Controller), c.efrom)
					if (ctrlConn !== null && ctrlConn.isBidirec) {
						error(
							c.efrom.name + " on " + c.from.name +
								" is used as the start of a unidirectional connection, but " + c.from.name +
								" contains a bidirectional connection to " + c.efrom.name,
							c,
							RoboChartPackage.Literals.CONNECTION__FROM,
							index
						)
					} else if (ctrlConn !== null && ctrlConn.to !== ctrlDef(c.from as Controller)) {
						error(
							c.efrom.name + " on " + c.from.name +
								" is used as the start of a unidirectional connection, but " + c.from.name +
								" contains a connection from " + c.efrom.name,
							c,
							RoboChartPackage.Literals.CONNECTION__FROM,
							index
						)
					}
				}
			}
			index++
		}
	}

	/* T2 */
	@Check
	def checkTriggersAreInputs(Transition t) {
		if (t.trigger !== null) {
			if (t.trigger.get_type === TriggerType.OUTPUT || t.trigger.get_type === TriggerType.SYNC) {
				error(
					"Only simple or input communications can be used as transition triggers",
					RoboChartPackage.Literals.TRANSITION__TRIGGER
				)
			}
		}
	}

	@Check
	def checkAsExp(AsExp e) {
		val etype = e.exp.typeFor
		val type = e.type
		if (!typeCompatible(type, etype)) {
			error(
				'Value of type ' + etype.printType + ' cannot be cast as ' + type.printType,
				RoboChartPackage.Literals.AS_EXP__TYPE,
				'CastTypeError'
			)
		}
	}
	
	/* TODO: Provide identifier for new WFC */
	@Check
	def timedConditionInUntimedSemantics(Transition t) {
		if (t.condition !== null && t.condition.isClockExp) {
			warning(
				'A transition condition in '+t.stateMachineBody.name+' uses timed expressions. In the untimed semantics, the whole condition is ignored.',
				RoboChartPackage.Literals.TRANSITION__CONDITION,
				'timedConditionInUntimedSemantics'
			)
		}
	}

	def dispatch Set<String> constantsRequired(StateMachineDef m) {
		var set = new HashSet<String>();
		for (i : m.RInterfaces) {
			for (l : i.variableList) {
				if (l.modifier == VariableModifier.CONST) {
					for (v : l.vars)
						set.add(v.name)
				}
			}
		}
		return set

	}
	
	def dispatch Set<String> constantsRequired(OperationDef m) {
		var set = new HashSet<String>();
		for (i : m.RInterfaces) {
			for (l : i.variableList) {
				if (l.modifier == VariableModifier.CONST) {
					for (v : l.vars)
						set.add(v.name)
				}
			}
		}
		return set

	}

	def dispatch Set<String> constantsRequired(ControllerDef m) {
		var set = new HashSet<String>();
		for (i : m.RInterfaces) {
			for (l : i.variableList) {
				if (l.modifier == VariableModifier.CONST) {
					for (v : l.vars)
						set.add(v.name)
				}
			}
		}
		return set
	}

	def rewriteType(Type t, Map<String, Type> map) {
		if (t instanceof TypeRef) {
			val ref = t.ref
			if (ref instanceof PrimitiveType && map.containsKey(ref.name)) {
				val repl = EcoreUtil2.copy(map.get(ref.name));
				return repl;
			} else {
				return t;
			}
		} else {
			val refs = t.eAllContents.filter[x|x instanceof TypeRef && (x as TypeRef).ref instanceof PrimitiveType].
				toList
			for (x : refs) {
				val ref = (x as TypeRef).ref
				if (ref instanceof PrimitiveType && map.containsKey(ref.name)) {
					val repl = EcoreUtil2.copy(map.get(ref.name));
					EcoreUtil2.replace(x, repl);
				}
			}
			return t;
		}
	}

	def rewriteType(Type t, Resource res) {
		val map = new HashMap<String, Type>()
		// TODO: check exactly what this line is supposed to do. Type instantiations no longer exist. Need to account for named types however
		//(res.contents.get(0) as RCPackage).typeInstantiations.forEach[x|map.put(x.left.name, x.right)]
		return rewriteType(t, map)
	}

	/* Helper */
	def Boolean isClockExp(Expression e) {
		if (e instanceof BooleanExp) {
			return false
		} else if (e instanceof IntegerExp) {
			return false
		} else if (e instanceof RefExp) {
			return false
		} else if (e instanceof SetExp) {
			return false
		} else if (e instanceof SeqExp) {
			return false
		} else if (e instanceof CallExp) {
			return false
		} else if (e instanceof GreaterThan) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof GreaterOrEqual) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof LessThan) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof LessOrEqual) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Equals) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Different) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof And) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Or) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Implies) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Iff) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Not) {
			return e.exp.isClockExp
		} else if (e instanceof Plus) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Minus) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Mult) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Div) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Modulus) {
			return e.left.isClockExp || e.right.isClockExp
		} else if (e instanceof Neg) {
			return e.exp.isClockExp
		} else if (e instanceof Cat) {
			return false
		} else if (e instanceof ParExp) {
			return e.exp.isClockExp
		} else if (e instanceof ClockExp) {
			return true
		} else if (e instanceof TupleExp) {
			return false
		} else if (e instanceof ArrayExp) {
			return false
		} else if (e instanceof StateClockExp) {
			return true
		} else {
			return false
		}
	}
	
	def wfcE_NoInitVal(Expression e) {
		/* E1 */
		if (e instanceof SetComp) {
			if (e.variables.filter[v | v.initial !== null].size > 0) {
				error("E1: The variables declared in a set comprehension must not have initial values",
					RoboChartPackage.Literals.SET_COMP__VARIABLES,
					"SetCompNoInitVal"
				)
			}
		} else 
		/* E2 */
		if (e instanceof QuantifierExpression) {
			if (e.variables.filter[v | v.initial !== null].size > 0) {
				error("E2: Quantified variables in existential and universal quantifications must not have initial values",
					RoboChartPackage.Literals.QUANTIFIER_EXPRESSION__VARIABLES,
					"QuantExpNoInitVal"
				)
			}
		} else 
		/* E2 */
		if (e instanceof LambdaExp) {
			if (e.variables.filter[v | v.initial !== null].size > 0) {
				error("E3: The variables quantified in a lambda expression must not have initial values",
					RoboChartPackage.Literals.LAMBDA_EXP__VARIABLES,
					"LambdaExpNoInitVal"
				)
			}
		}
	}

	/**
	 * Identify containing StateMachineBody
	 * Termination requires absence of loops in containment hierarchy!
	 * @returns first StateMachineBody found in containment hierarchy or null if @par o is not transitively contained by a StateMachineBody
	 */
	def StateMachineBody identifyContainingStateMachineBody(EObject o) {
		if (o.eContainer instanceof StateMachineBody) {
			o.eContainer as StateMachineBody
		} else if (o.eContainer === null) {
			null
		} else {	
			identifyContainingStateMachineBody(o.eContainer)
		}
	}
	
	/* TS1 (is currently not allowed in RoboChart syntax) */
	@Check
	def wfcTS1_InvalidClockRef(ClockReset cr) {
		var stm = identifyContainingStateMachineBody(cr)
		if (stm !== null && !stm.clocks.contains(cr.clock)) {
			error("TS1: A clock reset #C may only reference a clock declared within the action's containing state-machine," 
				+ "or in the case of a trigger, within the trigger's containing state-machine",
				RoboChartPackage.Literals.CLOCK_RESET__CLOCK,
				"InvalidClockRef"
			)
		} 
	}

	/////////////// Introduced in probabilistic semantics generator ////////////
	@Check
	def junctionWFC_P_J1(Junction j) {
		if(j instanceof Initial) return
		val parent = j.eContainer as NodeContainer
		for (t : parent.transitions.filter[t|t.target === j]) {
			if(t.action !== null) {
				error(
					'Incoming transitions of a junction in ' + parent.name + ' couldn\'t have an action',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'incomingTransToJuncWithActionError'
				)
			}
		}
	}
	
	@Check
	def junctionWFC_PJ1(ProbabilisticJunction j) {
		val parent = j.eContainer as NodeContainer
		for (t : parent.transitions.filter[t|t.source === j]) {
			if(t.trigger !== null) {
				error(
					'Outgoing transitions of a ProbabilisticJunction in ' + parent.name + ' couldn\'t have a trigger',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'outgoingTransfromProbJuncWithTrigError'
				)
			}
		}
	}
	
	@Check
	def junctionWFC_PJ2(ProbabilisticJunction j) {
		val parent = j.eContainer as NodeContainer
		for (t : parent.transitions.filter[t|t.source === j]) {
			if(t.probability === null) {
				error(
					'Outgoing transitions of a ProbabilisticJunction in ' + parent.name + ' should have one probability value',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'outgoingTransProbJuncWithoutProbValueError'
                )
            }
        }
    }

	@Check
	def junctionWFC_PJ3(ProbabilisticJunction j) {
		val parent = j.eContainer as NodeContainer
		val lstExpr = new ArrayList<Expression>()
		
		for (t : parent.transitions.filter[t|t.source === j]) {
			lstExpr.add(t.probability)
		}
		
		if(!sumExprEq1(lstExpr)) {
			warning(
				'Sum of probabilities of outgoing transitions from a ProbabilisticJunction in ' + parent.name + ' might not be equal to 1',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'probsfromProbJuncNotEqual1'
			)
		}
	}
	
	def private Boolean sumExprEq1(List<Expression> exprs) {
		val num = exprs.filter[t|(t instanceof IntegerExp) || (t instanceof FloatExp)].size
		if(exprs.size === num) {
			var sum = 0.0
			for(e: exprs) {
				if(e instanceof IntegerExp) {
					sum = sum + (e as IntegerExp).value
				} else if(e instanceof FloatExp) {
					sum = sum + (e as FloatExp).value
				}
			}
			
			if(sum === 1.0) {
				return true;
			} else {
				return false;
			}
		}
		
		return false
	}
	
	@Check
	def junctionWFC_PJ4(ProbabilisticJunction j) {
		val parent = j.eContainer as NodeContainer
		
		for (t : parent.transitions.filter[t|t.target === j]) {
			if(t.probability !== null) {
				error(
					'Incoming transitions of a ProbabilisticJunction in ' + parent.name + ' couldn\'t have a probability value \'p{...}\'',
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'incomingTransitionToProbJuncWithProbValueError'
				)
				
			}
		}
	}
	
	@Check
	def junctionWFC_PT1(Transition t) {
		if(t.probability !== null && t.trigger !== null) {
			error(
				'Transition ' + t.name + ' couldn\'t have a probability value \'p{...}\' and a trigger at the same time',
				RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
				'probValueAndTriggerTogetherError'
			)
			
		}
	}
	
	@Check
	def junctionWFC_PT2(Transition t) {
		val parent = t.eContainer as NodeContainer
		if(t.probability !== null) {
			for (n : parent.nodes.filter[n|n === t.source]) {
				if(!(n instanceof ProbabilisticJunction)) {
					error(
					'The source of the transitions with a probability value ' + parent.name + ' should be ProbabilisticJunction, but it is ' + n,
					RoboChartPackage.Literals.NAMED_ELEMENT__NAME,
					'sourceOfTransWithProbValueNotProbJuncError'
					)
				}
			}
		}
    }
}
